82,836p
268,436p
822,951p
1,257c
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
41. Some programming languages manage to absorb change, but withstand progress.
55. A LISP programmer knows the value of everything, but the cost of nothing.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
47. As Will Rogers would have said, "There is no such thing as a free variable."
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
43. In software systems, it is often the early bird that makes the worm.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
90. Computation has made the tree flower.
98. In computing, the mean time to failure keeps getting shorter.
47. As Will Rogers would have said, "There is no such thing as a free variable."
111. Why did the Roman Empire collapse? What is Latin for office automation?
7. It is easier to write an incorrect program than understand a correct one.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
62. In computing, invariants are ephemeral.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
46. Like punning, programming is a play on words.
11. If you have a procedure with ten parameters, you probably missed some.
41. Some programming languages manage to absorb change, but withstand progress.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
21. Optimization hinders evolution.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
103. Purely applicative languages are poorly applicable.
104. The proof of a system's value is its existence.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
100. We will never run out of things to program as long as there is a single program around.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
63. When we write programs that "learn", it turns out that we do and they don't.
112. Computer Science is embarrassed by the computer.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
72. An adequate bootstrap is a contradiction in terms.
105. You can't communicate complexity, only an awareness of it.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
96. Computers don't introduce order anywhere as much as they expose opportunities.
105. You can't communicate complexity, only an awareness of it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
63. When we write programs that "learn", it turns out that we do and they don't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
98. In computing, the mean time to failure keeps getting shorter.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
66. Making something variable is easy. Controlling duration of constancy is the trick.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
12. Recursion is the root of computation since it trades description for time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
46. Like punning, programming is a play on words.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
4. Every program is a part of some other program and rarely fits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
90. Computation has made the tree flower.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
27. Once you understand how to write a program get someone else to write it.
22. A good system can't have a weak command language.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
40. There are two ways to write error-free programs; only the third one works.
114. Within a computer natural language is unnatural.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
111. Why did the Roman Empire collapse? What is Latin for office automation?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
11. If you have a procedure with ten parameters, you probably missed some.
95. Don't have good ideas if you aren't willing to be responsible for them.
27. Once you understand how to write a program get someone else to write it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
115. Most people find the concept of programming obvious, but the doing impossible.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
7. It is easier to write an incorrect program than understand a correct one.
31. Simplicity does not precede complexity, but follows it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
105. You can't communicate complexity, only an awareness of it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
119. Programming is an unnatural act.
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
17. If a listener nods his head when you're explaining your program, wake him up.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
38. Structured Programming supports the law of the excluded middle.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
108. Whenever two programmers meet to criticize their programs, both are silent.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
105. You can't communicate complexity, only an awareness of it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
103. Purely applicative languages are poorly applicable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
110. Editing is a rewording activity.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
15. Everything should be built top-down, except the first time.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
66. Making something variable is easy. Controlling duration of constancy is the trick.
76. It is the user who should parameterize procedures, not their creators.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
115. Most people find the concept of programming obvious, but the doing impossible.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
95. Don't have good ideas if you aren't willing to be responsible for them.
41. Some programming languages manage to absorb change, but withstand progress.
95. Don't have good ideas if you aren't willing to be responsible for them.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
22. A good system can't have a weak command language.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
111. Why did the Roman Empire collapse? What is Latin for office automation?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
112. Computer Science is embarrassed by the computer.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
60. In seeking the unattainable, simplicity only gets in the way.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
17. If a listener nods his head when you're explaining your program, wake him up.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
.
204,780c
4. Every program is a part of some other program and rarely fits.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
95. Don't have good ideas if you aren't willing to be responsible for them.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
105. You can't communicate complexity, only an awareness of it.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
60. In seeking the unattainable, simplicity only gets in the way.
41. Some programming languages manage to absorb change, but withstand progress.
79. A year spent in artificial intelligence is enough to make one believe in God.
119. Programming is an unnatural act.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
46. Like punning, programming is a play on words.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
98. In computing, the mean time to failure keeps getting shorter.
46. Like punning, programming is a play on words.
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
103. Purely applicative languages are poorly applicable.
4. Every program is a part of some other program and rarely fits.
72. An adequate bootstrap is a contradiction in terms.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
22. A good system can't have a weak command language.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
15. Everything should be built top-down, except the first time.
95. Don't have good ideas if you aren't willing to be responsible for them.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
102. One can't proceed from the informal to the formal by formal means.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
79. A year spent in artificial intelligence is enough to make one believe in God.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
12. Recursion is the root of computation since it trades description for time.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
95. Don't have good ideas if you aren't willing to be responsible for them.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
55. A LISP programmer knows the value of everything, but the cost of nothing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
102. One can't proceed from the informal to the formal by formal means.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
119. Programming is an unnatural act.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
66. Making something variable is easy. Controlling duration of constancy is the trick.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
14. In the long run every program becomes rococo - then rubble.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
111. Why did the Roman Empire collapse? What is Latin for office automation?
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
14. In the long run every program becomes rococo - then rubble.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
78. If your computer speaks English, it was probably made in Japan.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
102. One can't proceed from the informal to the formal by formal means.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
100. We will never run out of things to program as long as there is a single program around.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
104. The proof of a system's value is its existence.
31. Simplicity does not precede complexity, but follows it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
102. One can't proceed from the informal to the formal by formal means.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
38. Structured Programming supports the law of the excluded middle.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
22. A good system can't have a weak command language.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
115. Most people find the concept of programming obvious, but the doing impossible.
115. Most people find the concept of programming obvious, but the doing impossible.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
72. An adequate bootstrap is a contradiction in terms.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
22. A good system can't have a weak command language.
46. Like punning, programming is a play on words.
21. Optimization hinders evolution.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
95. Don't have good ideas if you aren't willing to be responsible for them.
100. We will never run out of things to program as long as there is a single program around.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
14. In the long run every program becomes rococo - then rubble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
57. It is easier to change the specification to fit the program than vice versa.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
23. To understand a program you must become both the machine and the program.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
21. Optimization hinders evolution.
1. One man's constant is another man's variable.
22. A good system can't have a weak command language.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
38. Structured Programming supports the law of the excluded middle.
63. When we write programs that "learn", it turns out that we do and they don't.
46. Like punning, programming is a play on words.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
57. It is easier to change the specification to fit the program than vice versa.
98. In computing, the mean time to failure keeps getting shorter.
43. In software systems, it is often the early bird that makes the worm.
105. You can't communicate complexity, only an awareness of it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
40. There are two ways to write error-free programs; only the third one works.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
79. A year spent in artificial intelligence is enough to make one believe in God.
57. It is easier to change the specification to fit the program than vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
57. It is easier to change the specification to fit the program than vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
38. Structured Programming supports the law of the excluded middle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
76. It is the user who should parameterize procedures, not their creators.
40. There are two ways to write error-free programs; only the third one works.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
90. Computation has made the tree flower.
57. It is easier to change the specification to fit the program than vice versa.
46. Like punning, programming is a play on words.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
22. A good system can't have a weak command language.
12. Recursion is the root of computation since it trades description for time.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
8. A programming language is low level when its programs require attention to the irrelevant.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
66. Making something variable is easy. Controlling duration of constancy is the trick.
4. Every program is a part of some other program and rarely fits.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
21. Optimization hinders evolution.
111. Why did the Roman Empire collapse? What is Latin for office automation?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
102. One can't proceed from the informal to the formal by formal means.
98. In computing, the mean time to failure keeps getting shorter.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
41. Some programming languages manage to absorb change, but withstand progress.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
12. Recursion is the root of computation since it trades description for time.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
115. Most people find the concept of programming obvious, but the doing impossible.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
111. Why did the Roman Empire collapse? What is Latin for office automation?
95. Don't have good ideas if you aren't willing to be responsible for them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
27. Once you understand how to write a program get someone else to write it.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
63. When we write programs that "learn", it turns out that we do and they don't.
104. The proof of a system's value is its existence.
95. Don't have good ideas if you aren't willing to be responsible for them.
79. A year spent in artificial intelligence is enough to make one believe in God.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
103. Purely applicative languages are poorly applicable.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
90. Computation has made the tree flower.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
98. In computing, the mean time to failure keeps getting shorter.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
40. There are two ways to write error-free programs; only the third one works.
62. In computing, invariants are ephemeral.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
46. Like punning, programming is a play on words.
40. There are two ways to write error-free programs; only the third one works.
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
22. A good system can't have a weak command language.
98. In computing, the mean time to failure keeps getting shorter.
43. In software systems, it is often the early bird that makes the worm.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
18. A program without a loop and a structured variable isn't worth writing.
46. Like punning, programming is a play on words.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
115. Most people find the concept of programming obvious, but the doing impossible.
61. In programming, as in everything else, to be in error is to be reborn.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
95. Don't have good ideas if you aren't willing to be responsible for them.
115. Most people find the concept of programming obvious, but the doing impossible.
110. Editing is a rewording activity.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
108. Whenever two programmers meet to criticize their programs, both are silent.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
7. It is easier to write an incorrect program than understand a correct one.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
111. Why did the Roman Empire collapse? What is Latin for office automation?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
3. Syntactic sugar causes cancer of the semicolon.
119. Programming is an unnatural act.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
1. One man's constant is another man's variable.
115. Most people find the concept of programming obvious, but the doing impossible.
55. A LISP programmer knows the value of everything, but the cost of nothing.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
15. Everything should be built top-down, except the first time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
76. It is the user who should parameterize procedures, not their creators.
57. It is easier to change the specification to fit the program than vice versa.
7. It is easier to write an incorrect program than understand a correct one.
66. Making something variable is easy. Controlling duration of constancy is the trick.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
112. Computer Science is embarrassed by the computer.
115. Most people find the concept of programming obvious, but the doing impossible.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
59. In English every word can be verbed. Would that it were so in our programming languages.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
95. Don't have good ideas if you aren't willing to be responsible for them.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
62. In computing, invariants are ephemeral.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
112. Computer Science is embarrassed by the computer.
38. Structured Programming supports the law of the excluded middle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
112. Computer Science is embarrassed by the computer.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
14. In the long run every program becomes rococo - then rubble.
62. In computing, invariants are ephemeral.
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
114. Within a computer natural language is unnatural.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
112. Computer Science is embarrassed by the computer.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
95. Don't have good ideas if you aren't willing to be responsible for them.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
103. Purely applicative languages are poorly applicable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
41. Some programming languages manage to absorb change, but withstand progress.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
78. If your computer speaks English, it was probably made in Japan.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
102. One can't proceed from the informal to the formal by formal means.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
15. Everything should be built top-down, except the first time.
1. One man's constant is another man's variable.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
43. In software systems, it is often the early bird that makes the worm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
100. We will never run out of things to program as long as there is a single program around.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
108. Whenever two programmers meet to criticize their programs, both are silent.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
1. One man's constant is another man's variable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
43. In software systems, it is often the early bird that makes the worm.
14. In the long run every program becomes rococo - then rubble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
31. Simplicity does not precede complexity, but follows it.
23. To understand a program you must become both the machine and the program.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
63. When we write programs that "learn", it turns out that we do and they don't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
3. Syntactic sugar causes cancer of the semicolon.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
100. We will never run out of things to program as long as there is a single program around.
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
47. As Will Rogers would have said, "There is no such thing as a free variable."
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
21. Optimization hinders evolution.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
40. There are two ways to write error-free programs; only the third one works.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
4. Every program is a part of some other program and rarely fits.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
40. There are two ways to write error-free programs; only the third one works.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
102. One can't proceed from the informal to the formal by formal means.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
4. Every program is a part of some other program and rarely fits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
60. In seeking the unattainable, simplicity only gets in the way.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
43. In software systems, it is often the early bird that makes the worm.
46. Like punning, programming is a play on words.
17. If a listener nods his head when you're explaining your program, wake him up.
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
110. Editing is a rewording activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
43. In software systems, it is often the early bird that makes the worm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
100. We will never run out of things to program as long as there is a single program around.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
63. When we write programs that "learn", it turns out that we do and they don't.
102. One can't proceed from the informal to the formal by formal means.
76. It is the user who should parameterize procedures, not their creators.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
104. The proof of a system's value is its existence.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
96. Computers don't introduce order anywhere as much as they expose opportunities.
21. Optimization hinders evolution.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
115. Most people find the concept of programming obvious, but the doing impossible.
4. Every program is a part of some other program and rarely fits.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
55. A LISP programmer knows the value of everything, but the cost of nothing.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
98. In computing, the mean time to failure keeps getting shorter.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
112. Computer Science is embarrassed by the computer.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
108. Whenever two programmers meet to criticize their programs, both are silent.
79. A year spent in artificial intelligence is enough to make one believe in God.
57. It is easier to change the specification to fit the program than vice versa.
112. Computer Science is embarrassed by the computer.
4. Every program is a part of some other program and rarely fits.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
59. In English every word can be verbed. Would that it were so in our programming languages.
.
706,829c
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
21. Optimization hinders evolution.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
14. In the long run every program becomes rococo - then rubble.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
100. We will never run out of things to program as long as there is a single program around.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
18. A program without a loop and a structured variable isn't worth writing.
21. Optimization hinders evolution.
8. A programming language is low level when its programs require attention to the irrelevant.
15. Everything should be built top-down, except the first time.
59. In English every word can be verbed. Would that it were so in our programming languages.
46. Like punning, programming is a play on words.
112. Computer Science is embarrassed by the computer.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
66. Making something variable is easy. Controlling duration of constancy is the trick.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
8. A programming language is low level when its programs require attention to the irrelevant.
63. When we write programs that "learn", it turns out that we do and they don't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
7. It is easier to write an incorrect program than understand a correct one.
103. Purely applicative languages are poorly applicable.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
43. In software systems, it is often the early bird that makes the worm.
23. To understand a program you must become both the machine and the program.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
12. Recursion is the root of computation since it trades description for time.
4. Every program is a part of some other program and rarely fits.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
100. We will never run out of things to program as long as there is a single program around.
3. Syntactic sugar causes cancer of the semicolon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
18. A program without a loop and a structured variable isn't worth writing.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
76. It is the user who should parameterize procedures, not their creators.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
62. In computing, invariants are ephemeral.
12. Recursion is the root of computation since it trades description for time.
38. Structured Programming supports the law of the excluded middle.
90. Computation has made the tree flower.
114. Within a computer natural language is unnatural.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
3. Syntactic sugar causes cancer of the semicolon.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
102. One can't proceed from the informal to the formal by formal means.
115. Most people find the concept of programming obvious, but the doing impossible.
22. A good system can't have a weak command language.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
.
754,909p
214,705c
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
15. Everything should be built top-down, except the first time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
100. We will never run out of things to program as long as there is a single program around.
103. Purely applicative languages are poorly applicable.
57. It is easier to change the specification to fit the program than vice versa.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
95. Don't have good ideas if you aren't willing to be responsible for them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
61. In programming, as in everything else, to be in error is to be reborn.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
31. Simplicity does not precede complexity, but follows it.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
40. There are two ways to write error-free programs; only the third one works.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
47. As Will Rogers would have said, "There is no such thing as a free variable."
60. In seeking the unattainable, simplicity only gets in the way.
62. In computing, invariants are ephemeral.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
62. In computing, invariants are ephemeral.
95. Don't have good ideas if you aren't willing to be responsible for them.
18. A program without a loop and a structured variable isn't worth writing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
96. Computers don't introduce order anywhere as much as they expose opportunities.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
1. One man's constant is another man's variable.
72. An adequate bootstrap is a contradiction in terms.
12. Recursion is the root of computation since it trades description for time.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
14. In the long run every program becomes rococo - then rubble.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
7. It is easier to write an incorrect program than understand a correct one.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
103. Purely applicative languages are poorly applicable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
47. As Will Rogers would have said, "There is no such thing as a free variable."
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
7. It is easier to write an incorrect program than understand a correct one.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
55. A LISP programmer knows the value of everything, but the cost of nothing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
78. If your computer speaks English, it was probably made in Japan.
11. If you have a procedure with ten parameters, you probably missed some.
66. Making something variable is easy. Controlling duration of constancy is the trick.
112. Computer Science is embarrassed by the computer.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
102. One can't proceed from the informal to the formal by formal means.
18. A program without a loop and a structured variable isn't worth writing.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
111. Why did the Roman Empire collapse? What is Latin for office automation?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
95. Don't have good ideas if you aren't willing to be responsible for them.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
98. In computing, the mean time to failure keeps getting shorter.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
27. Once you understand how to write a program get someone else to write it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
18. A program without a loop and a structured variable isn't worth writing.
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
46. Like punning, programming is a play on words.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
47. As Will Rogers would have said, "There is no such thing as a free variable."
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
111. Why did the Roman Empire collapse? What is Latin for office automation?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
23. To understand a program you must become both the machine and the program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
15. Everything should be built top-down, except the first time.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
18. A program without a loop and a structured variable isn't worth writing.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
43. In software systems, it is often the early bird that makes the worm.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
63. When we write programs that "learn", it turns out that we do and they don't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
110. Editing is a rewording activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
12. Recursion is the root of computation since it trades description for time.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
62. In computing, invariants are ephemeral.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
43. In software systems, it is often the early bird that makes the worm.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
27. Once you understand how to write a program get someone else to write it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
72. An adequate bootstrap is a contradiction in terms.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
108. Whenever two programmers meet to criticize their programs, both are silent.
103. Purely applicative languages are poorly applicable.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
43. In software systems, it is often the early bird that makes the worm.
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
4. Every program is a part of some other program and rarely fits.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
38. Structured Programming supports the law of the excluded middle.
62. In computing, invariants are ephemeral.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
59. In English every word can be verbed. Would that it were so in our programming languages.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
114. Within a computer natural language is unnatural.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
43. In software systems, it is often the early bird that makes the worm.
22. A good system can't have a weak command language.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
105. You can't communicate complexity, only an awareness of it.
46. Like punning, programming is a play on words.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
22. A good system can't have a weak command language.
43. In software systems, it is often the early bird that makes the worm.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
115. Most people find the concept of programming obvious, but the doing impossible.
72. An adequate bootstrap is a contradiction in terms.
79. A year spent in artificial intelligence is enough to make one believe in God.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
100. We will never run out of things to program as long as there is a single program around.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
17. If a listener nods his head when you're explaining your program, wake him up.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
12. Recursion is the root of computation since it trades description for time.
114. Within a computer natural language is unnatural.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
11. If you have a procedure with ten parameters, you probably missed some.
103. Purely applicative languages are poorly applicable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
46. Like punning, programming is a play on words.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
100. We will never run out of things to program as long as there is a single program around.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
61. In programming, as in everything else, to be in error is to be reborn.
60. In seeking the unattainable, simplicity only gets in the way.
98. In computing, the mean time to failure keeps getting shorter.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
59. In English every word can be verbed. Would that it were so in our programming languages.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
55. A LISP programmer knows the value of everything, but the cost of nothing.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
47. As Will Rogers would have said, "There is no such thing as a free variable."
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
22. A good system can't have a weak command language.
61. In programming, as in everything else, to be in error is to be reborn.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
27. Once you understand how to write a program get someone else to write it.
104. The proof of a system's value is its existence.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
7. It is easier to write an incorrect program than understand a correct one.
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
95. Don't have good ideas if you aren't willing to be responsible for them.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
46. Like punning, programming is a play on words.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
72. An adequate bootstrap is a contradiction in terms.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
31. Simplicity does not precede complexity, but follows it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
108. Whenever two programmers meet to criticize their programs, both are silent.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
103. Purely applicative languages are poorly applicable.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
14. In the long run every program becomes rococo - then rubble.
79. A year spent in artificial intelligence is enough to make one believe in God.
40. There are two ways to write error-free programs; only the third one works.
62. In computing, invariants are ephemeral.
40. There are two ways to write error-free programs; only the third one works.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
41. Some programming languages manage to absorb change, but withstand progress.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
38. Structured Programming supports the law of the excluded middle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
15. Everything should be built top-down, except the first time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
21. Optimization hinders evolution.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
22. A good system can't have a weak command language.
119. Programming is an unnatural act.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
78. If your computer speaks English, it was probably made in Japan.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
76. It is the user who should parameterize procedures, not their creators.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
7. It is easier to write an incorrect program than understand a correct one.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
110. Editing is a rewording activity.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
104. The proof of a system's value is its existence.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
115. Most people find the concept of programming obvious, but the doing impossible.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
60. In seeking the unattainable, simplicity only gets in the way.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
66. Making something variable is easy. Controlling duration of constancy is the trick.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
1. One man's constant is another man's variable.
3. Syntactic sugar causes cancer of the semicolon.
95. Don't have good ideas if you aren't willing to be responsible for them.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
119. Programming is an unnatural act.
90. Computation has made the tree flower.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
100. We will never run out of things to program as long as there is a single program around.
60. In seeking the unattainable, simplicity only gets in the way.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
66. Making something variable is easy. Controlling duration of constancy is the trick.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
23. To understand a program you must become both the machine and the program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
46. Like punning, programming is a play on words.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
100. We will never run out of things to program as long as there is a single program around.
47. As Will Rogers would have said, "There is no such thing as a free variable."
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
108. Whenever two programmers meet to criticize their programs, both are silent.
63. When we write programs that "learn", it turns out that we do and they don't.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
76. It is the user who should parameterize procedures, not their creators.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
31. Simplicity does not precede complexity, but follows it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
108. Whenever two programmers meet to criticize their programs, both are silent.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
103. Purely applicative languages are poorly applicable.
90. Computation has made the tree flower.
7. It is easier to write an incorrect program than understand a correct one.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
17. If a listener nods his head when you're explaining your program, wake him up.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
8. A programming language is low level when its programs require attention to the irrelevant.
.
q
