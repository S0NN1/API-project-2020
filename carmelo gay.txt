841,886d
1,875c
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
47. As Will Rogers would have said, "There is no such thing as a free variable."
110. Editing is a rewording activity.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
27. Once you understand how to write a program get someone else to write it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
12. Recursion is the root of computation since it trades description for time.
27. Once you understand how to write a program get someone else to write it.
11. If you have a procedure with ten parameters, you probably missed some.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
47. As Will Rogers would have said, "There is no such thing as a free variable."
96. Computers don't introduce order anywhere as much as they expose opportunities.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
38. Structured Programming supports the law of the excluded middle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
79. A year spent in artificial intelligence is enough to make one believe in God.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
112. Computer Science is embarrassed by the computer.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
1. One man's constant is another man's variable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
38. Structured Programming supports the law of the excluded middle.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
59. In English every word can be verbed. Would that it were so in our programming languages.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
119. Programming is an unnatural act.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
43. In software systems, it is often the early bird that makes the worm.
76. It is the user who should parameterize procedures, not their creators.
61. In programming, as in everything else, to be in error is to be reborn.
47. As Will Rogers would have said, "There is no such thing as a free variable."
102. One can't proceed from the informal to the formal by formal means.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
55. A LISP programmer knows the value of everything, but the cost of nothing.
78. If your computer speaks English, it was probably made in Japan.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
110. Editing is a rewording activity.
60. In seeking the unattainable, simplicity only gets in the way.
41. Some programming languages manage to absorb change, but withstand progress.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
15. Everything should be built top-down, except the first time.
102. One can't proceed from the informal to the formal by formal means.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
104. The proof of a system's value is its existence.
96. Computers don't introduce order anywhere as much as they expose opportunities.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
60. In seeking the unattainable, simplicity only gets in the way.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
27. Once you understand how to write a program get someone else to write it.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
11. If you have a procedure with ten parameters, you probably missed some.
105. You can't communicate complexity, only an awareness of it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
15. Everything should be built top-down, except the first time.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
72. An adequate bootstrap is a contradiction in terms.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
112. Computer Science is embarrassed by the computer.
111. Why did the Roman Empire collapse? What is Latin for office automation?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
21. Optimization hinders evolution.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
59. In English every word can be verbed. Would that it were so in our programming languages.
110. Editing is a rewording activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
38. Structured Programming supports the law of the excluded middle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
78. If your computer speaks English, it was probably made in Japan.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
60. In seeking the unattainable, simplicity only gets in the way.
98. In computing, the mean time to failure keeps getting shorter.
23. To understand a program you must become both the machine and the program.
95. Don't have good ideas if you aren't willing to be responsible for them.
105. You can't communicate complexity, only an awareness of it.
59. In English every word can be verbed. Would that it were so in our programming languages.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
98. In computing, the mean time to failure keeps getting shorter.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
111. Why did the Roman Empire collapse? What is Latin for office automation?
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
114. Within a computer natural language is unnatural.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
47. As Will Rogers would have said, "There is no such thing as a free variable."
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
40. There are two ways to write error-free programs; only the third one works.
7. It is easier to write an incorrect program than understand a correct one.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
18. A program without a loop and a structured variable isn't worth writing.
119. Programming is an unnatural act.
119. Programming is an unnatural act.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
119. Programming is an unnatural act.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
79. A year spent in artificial intelligence is enough to make one believe in God.
8. A programming language is low level when its programs require attention to the irrelevant.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
103. Purely applicative languages are poorly applicable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
119. Programming is an unnatural act.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
66. Making something variable is easy. Controlling duration of constancy is the trick.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
22. A good system can't have a weak command language.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
66. Making something variable is easy. Controlling duration of constancy is the trick.
15. Everything should be built top-down, except the first time.
23. To understand a program you must become both the machine and the program.
66. Making something variable is easy. Controlling duration of constancy is the trick.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
46. Like punning, programming is a play on words.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
90. Computation has made the tree flower.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
38. Structured Programming supports the law of the excluded middle.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
79. A year spent in artificial intelligence is enough to make one believe in God.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
55. A LISP programmer knows the value of everything, but the cost of nothing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
95. Don't have good ideas if you aren't willing to be responsible for them.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
27. Once you understand how to write a program get someone else to write it.
108. Whenever two programmers meet to criticize their programs, both are silent.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
112. Computer Science is embarrassed by the computer.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
22. A good system can't have a weak command language.
15. Everything should be built top-down, except the first time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
41. Some programming languages manage to absorb change, but withstand progress.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
1. One man's constant is another man's variable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
104. The proof of a system's value is its existence.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
110. Editing is a rewording activity.
66. Making something variable is easy. Controlling duration of constancy is the trick.
57. It is easier to change the specification to fit the program than vice versa.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
105. You can't communicate complexity, only an awareness of it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
23. To understand a program you must become both the machine and the program.
18. A program without a loop and a structured variable isn't worth writing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
12. Recursion is the root of computation since it trades description for time.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
119. Programming is an unnatural act.
3. Syntactic sugar causes cancer of the semicolon.
76. It is the user who should parameterize procedures, not their creators.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
31. Simplicity does not precede complexity, but follows it.
18. A program without a loop and a structured variable isn't worth writing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
119. Programming is an unnatural act.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
102. One can't proceed from the informal to the formal by formal means.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
100. We will never run out of things to program as long as there is a single program around.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
98. In computing, the mean time to failure keeps getting shorter.
114. Within a computer natural language is unnatural.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
41. Some programming languages manage to absorb change, but withstand progress.
47. As Will Rogers would have said, "There is no such thing as a free variable."
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
102. One can't proceed from the informal to the formal by formal means.
17. If a listener nods his head when you're explaining your program, wake him up.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
57. It is easier to change the specification to fit the program than vice versa.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
76. It is the user who should parameterize procedures, not their creators.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
46. Like punning, programming is a play on words.
17. If a listener nods his head when you're explaining your program, wake him up.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
103. Purely applicative languages are poorly applicable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
59. In English every word can be verbed. Would that it were so in our programming languages.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
3. Syntactic sugar causes cancer of the semicolon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
110. Editing is a rewording activity.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
47. As Will Rogers would have said, "There is no such thing as a free variable."
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
4. Every program is a part of some other program and rarely fits.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
105. You can't communicate complexity, only an awareness of it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
60. In seeking the unattainable, simplicity only gets in the way.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
8. A programming language is low level when its programs require attention to the irrelevant.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
119. Programming is an unnatural act.
119. Programming is an unnatural act.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
102. One can't proceed from the informal to the formal by formal means.
61. In programming, as in everything else, to be in error is to be reborn.
105. You can't communicate complexity, only an awareness of it.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
72. An adequate bootstrap is a contradiction in terms.
76. It is the user who should parameterize procedures, not their creators.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
46. Like punning, programming is a play on words.
95. Don't have good ideas if you aren't willing to be responsible for them.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
95. Don't have good ideas if you aren't willing to be responsible for them.
61. In programming, as in everything else, to be in error is to be reborn.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
41. Some programming languages manage to absorb change, but withstand progress.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
31. Simplicity does not precede complexity, but follows it.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
3. Syntactic sugar causes cancer of the semicolon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
110. Editing is a rewording activity.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
104. The proof of a system's value is its existence.
78. If your computer speaks English, it was probably made in Japan.
8. A programming language is low level when its programs require attention to the irrelevant.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
57. It is easier to change the specification to fit the program than vice versa.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
78. If your computer speaks English, it was probably made in Japan.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
119. Programming is an unnatural act.
8. A programming language is low level when its programs require attention to the irrelevant.
72. An adequate bootstrap is a contradiction in terms.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
60. In seeking the unattainable, simplicity only gets in the way.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
18. A program without a loop and a structured variable isn't worth writing.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
111. Why did the Roman Empire collapse? What is Latin for office automation?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
46. Like punning, programming is a play on words.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
59. In English every word can be verbed. Would that it were so in our programming languages.
115. Most people find the concept of programming obvious, but the doing impossible.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
98. In computing, the mean time to failure keeps getting shorter.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
7. It is easier to write an incorrect program than understand a correct one.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
7. It is easier to write an incorrect program than understand a correct one.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
55. A LISP programmer knows the value of everything, but the cost of nothing.
22. A good system can't have a weak command language.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
76. It is the user who should parameterize procedures, not their creators.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
78. If your computer speaks English, it was probably made in Japan.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
59. In English every word can be verbed. Would that it were so in our programming languages.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
104. The proof of a system's value is its existence.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
111. Why did the Roman Empire collapse? What is Latin for office automation?
110. Editing is a rewording activity.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
66. Making something variable is easy. Controlling duration of constancy is the trick.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
79. A year spent in artificial intelligence is enough to make one believe in God.
7. It is easier to write an incorrect program than understand a correct one.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
114. Within a computer natural language is unnatural.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
110. Editing is a rewording activity.
55. A LISP programmer knows the value of everything, but the cost of nothing.
17. If a listener nods his head when you're explaining your program, wake him up.
59. In English every word can be verbed. Would that it were so in our programming languages.
114. Within a computer natural language is unnatural.
103. Purely applicative languages are poorly applicable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
15. Everything should be built top-down, except the first time.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
31. Simplicity does not precede complexity, but follows it.
63. When we write programs that "learn", it turns out that we do and they don't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
21. Optimization hinders evolution.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
31. Simplicity does not precede complexity, but follows it.
61. In programming, as in everything else, to be in error is to be reborn.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
79. A year spent in artificial intelligence is enough to make one believe in God.
46. Like punning, programming is a play on words.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
110. Editing is a rewording activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
3. Syntactic sugar causes cancer of the semicolon.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
66. Making something variable is easy. Controlling duration of constancy is the trick.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
111. Why did the Roman Empire collapse? What is Latin for office automation?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
38. Structured Programming supports the law of the excluded middle.
78. If your computer speaks English, it was probably made in Japan.
17. If a listener nods his head when you're explaining your program, wake him up.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
31. Simplicity does not precede complexity, but follows it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
100. We will never run out of things to program as long as there is a single program around.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
31. Simplicity does not precede complexity, but follows it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
22. A good system can't have a weak command language.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
17. If a listener nods his head when you're explaining your program, wake him up.
47. As Will Rogers would have said, "There is no such thing as a free variable."
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
40. There are two ways to write error-free programs; only the third one works.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
3. Syntactic sugar causes cancer of the semicolon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
57. It is easier to change the specification to fit the program than vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
110. Editing is a rewording activity.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
22. A good system can't have a weak command language.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
96. Computers don't introduce order anywhere as much as they expose opportunities.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
100. We will never run out of things to program as long as there is a single program around.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
96. Computers don't introduce order anywhere as much as they expose opportunities.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
96. Computers don't introduce order anywhere as much as they expose opportunities.
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
119. Programming is an unnatural act.
95. Don't have good ideas if you aren't willing to be responsible for them.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
79. A year spent in artificial intelligence is enough to make one believe in God.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
46. Like punning, programming is a play on words.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
110. Editing is a rewording activity.
62. In computing, invariants are ephemeral.
4. Every program is a part of some other program and rarely fits.
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
31. Simplicity does not precede complexity, but follows it.
104. The proof of a system's value is its existence.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
103. Purely applicative languages are poorly applicable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
43. In software systems, it is often the early bird that makes the worm.
110. Editing is a rewording activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
8. A programming language is low level when its programs require attention to the irrelevant.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
40. There are two ways to write error-free programs; only the third one works.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
12. Recursion is the root of computation since it trades description for time.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
100. We will never run out of things to program as long as there is a single program around.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
95. Don't have good ideas if you aren't willing to be responsible for them.
21. Optimization hinders evolution.
11. If you have a procedure with ten parameters, you probably missed some.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
103. Purely applicative languages are poorly applicable.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
90. Computation has made the tree flower.
21. Optimization hinders evolution.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
61. In programming, as in everything else, to be in error is to be reborn.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
95. Don't have good ideas if you aren't willing to be responsible for them.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
15. Everything should be built top-down, except the first time.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
72. An adequate bootstrap is a contradiction in terms.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
95. Don't have good ideas if you aren't willing to be responsible for them.
103. Purely applicative languages are poorly applicable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
95. Don't have good ideas if you aren't willing to be responsible for them.
114. Within a computer natural language is unnatural.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
105. You can't communicate complexity, only an awareness of it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
41. Some programming languages manage to absorb change, but withstand progress.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
103. Purely applicative languages are poorly applicable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
76. It is the user who should parameterize procedures, not their creators.
41. Some programming languages manage to absorb change, but withstand progress.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
.
578,613c
119. Programming is an unnatural act.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
38. Structured Programming supports the law of the excluded middle.
11. If you have a procedure with ten parameters, you probably missed some.
4. Every program is a part of some other program and rarely fits.
57. It is easier to change the specification to fit the program than vice versa.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
90. Computation has made the tree flower.
60. In seeking the unattainable, simplicity only gets in the way.
57. It is easier to change the specification to fit the program than vice versa.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
76. It is the user who should parameterize procedures, not their creators.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
72. An adequate bootstrap is a contradiction in terms.
40. There are two ways to write error-free programs; only the third one works.
108. Whenever two programmers meet to criticize their programs, both are silent.
43. In software systems, it is often the early bird that makes the worm.
115. Most people find the concept of programming obvious, but the doing impossible.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
62. In computing, invariants are ephemeral.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
.
71,251d
104,574d
704,760d
38,734c
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
60. In seeking the unattainable, simplicity only gets in the way.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
18. A program without a loop and a structured variable isn't worth writing.
78. If your computer speaks English, it was probably made in Japan.
17. If a listener nods his head when you're explaining your program, wake him up.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
1. One man's constant is another man's variable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
46. Like punning, programming is a play on words.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
46. Like punning, programming is a play on words.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
112. Computer Science is embarrassed by the computer.
111. Why did the Roman Empire collapse? What is Latin for office automation?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
105. You can't communicate complexity, only an awareness of it.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
114. Within a computer natural language is unnatural.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
59. In English every word can be verbed. Would that it were so in our programming languages.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
23. To understand a program you must become both the machine and the program.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
8. A programming language is low level when its programs require attention to the irrelevant.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
61. In programming, as in everything else, to be in error is to be reborn.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
104. The proof of a system's value is its existence.
103. Purely applicative languages are poorly applicable.
95. Don't have good ideas if you aren't willing to be responsible for them.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
17. If a listener nods his head when you're explaining your program, wake him up.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
15. Everything should be built top-down, except the first time.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
96. Computers don't introduce order anywhere as much as they expose opportunities.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
104. The proof of a system's value is its existence.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
119. Programming is an unnatural act.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
8. A programming language is low level when its programs require attention to the irrelevant.
4. Every program is a part of some other program and rarely fits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
22. A good system can't have a weak command language.
115. Most people find the concept of programming obvious, but the doing impossible.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
11. If you have a procedure with ten parameters, you probably missed some.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
14. In the long run every program becomes rococo - then rubble.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
59. In English every word can be verbed. Would that it were so in our programming languages.
104. The proof of a system's value is its existence.
98. In computing, the mean time to failure keeps getting shorter.
119. Programming is an unnatural act.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
15. Everything should be built top-down, except the first time.
15. Everything should be built top-down, except the first time.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
105. You can't communicate complexity, only an awareness of it.
4. Every program is a part of some other program and rarely fits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
104. The proof of a system's value is its existence.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
102. One can't proceed from the informal to the formal by formal means.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
40. There are two ways to write error-free programs; only the third one works.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
100. We will never run out of things to program as long as there is a single program around.
105. You can't communicate complexity, only an awareness of it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
108. Whenever two programmers meet to criticize their programs, both are silent.
98. In computing, the mean time to failure keeps getting shorter.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
12. Recursion is the root of computation since it trades description for time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
100. We will never run out of things to program as long as there is a single program around.
114. Within a computer natural language is unnatural.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
96. Computers don't introduce order anywhere as much as they expose opportunities.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
1. One man's constant is another man's variable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
22. A good system can't have a weak command language.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
96. Computers don't introduce order anywhere as much as they expose opportunities.
110. Editing is a rewording activity.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
95. Don't have good ideas if you aren't willing to be responsible for them.
103. Purely applicative languages are poorly applicable.
63. When we write programs that "learn", it turns out that we do and they don't.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
95. Don't have good ideas if you aren't willing to be responsible for them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
62. In computing, invariants are ephemeral.
4. Every program is a part of some other program and rarely fits.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
27. Once you understand how to write a program get someone else to write it.
76. It is the user who should parameterize procedures, not their creators.
112. Computer Science is embarrassed by the computer.
62. In computing, invariants are ephemeral.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
66. Making something variable is easy. Controlling duration of constancy is the trick.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
63. When we write programs that "learn", it turns out that we do and they don't.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
79. A year spent in artificial intelligence is enough to make one believe in God.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
104. The proof of a system's value is its existence.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
90. Computation has made the tree flower.
110. Editing is a rewording activity.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
57. It is easier to change the specification to fit the program than vice versa.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
38. Structured Programming supports the law of the excluded middle.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
1. One man's constant is another man's variable.
76. It is the user who should parameterize procedures, not their creators.
17. If a listener nods his head when you're explaining your program, wake him up.
110. Editing is a rewording activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
17. If a listener nods his head when you're explaining your program, wake him up.
38. Structured Programming supports the law of the excluded middle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
79. A year spent in artificial intelligence is enough to make one believe in God.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
112. Computer Science is embarrassed by the computer.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
90. Computation has made the tree flower.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
40. There are two ways to write error-free programs; only the third one works.
12. Recursion is the root of computation since it trades description for time.
43. In software systems, it is often the early bird that makes the worm.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
4. Every program is a part of some other program and rarely fits.
119. Programming is an unnatural act.
7. It is easier to write an incorrect program than understand a correct one.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
47. As Will Rogers would have said, "There is no such thing as a free variable."
18. A program without a loop and a structured variable isn't worth writing.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
27. Once you understand how to write a program get someone else to write it.
61. In programming, as in everything else, to be in error is to be reborn.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
105. You can't communicate complexity, only an awareness of it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
79. A year spent in artificial intelligence is enough to make one believe in God.
21. Optimization hinders evolution.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
22. A good system can't have a weak command language.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
12. Recursion is the root of computation since it trades description for time.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
3. Syntactic sugar causes cancer of the semicolon.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
8. A programming language is low level when its programs require attention to the irrelevant.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
27. Once you understand how to write a program get someone else to write it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
18. A program without a loop and a structured variable isn't worth writing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
47. As Will Rogers would have said, "There is no such thing as a free variable."
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
103. Purely applicative languages are poorly applicable.
3. Syntactic sugar causes cancer of the semicolon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
3. Syntactic sugar causes cancer of the semicolon.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
17. If a listener nods his head when you're explaining your program, wake him up.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
17. If a listener nods his head when you're explaining your program, wake him up.
90. Computation has made the tree flower.
4. Every program is a part of some other program and rarely fits.
57. It is easier to change the specification to fit the program than vice versa.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
105. You can't communicate complexity, only an awareness of it.
110. Editing is a rewording activity.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
1. One man's constant is another man's variable.
17. If a listener nods his head when you're explaining your program, wake him up.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
62. In computing, invariants are ephemeral.
12. Recursion is the root of computation since it trades description for time.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
76. It is the user who should parameterize procedures, not their creators.
102. One can't proceed from the informal to the formal by formal means.
41. Some programming languages manage to absorb change, but withstand progress.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
63. When we write programs that "learn", it turns out that we do and they don't.
12. Recursion is the root of computation since it trades description for time.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
115. Most people find the concept of programming obvious, but the doing impossible.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
40. There are two ways to write error-free programs; only the third one works.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
76. It is the user who should parameterize procedures, not their creators.
102. One can't proceed from the informal to the formal by formal means.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
57. It is easier to change the specification to fit the program than vice versa.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
1. One man's constant is another man's variable.
79. A year spent in artificial intelligence is enough to make one believe in God.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
14. In the long run every program becomes rococo - then rubble.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
14. In the long run every program becomes rococo - then rubble.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
31. Simplicity does not precede complexity, but follows it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
103. Purely applicative languages are poorly applicable.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
41. Some programming languages manage to absorb change, but withstand progress.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
90. Computation has made the tree flower.
8. A programming language is low level when its programs require attention to the irrelevant.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
105. You can't communicate complexity, only an awareness of it.
7. It is easier to write an incorrect program than understand a correct one.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
59. In English every word can be verbed. Would that it were so in our programming languages.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
110. Editing is a rewording activity.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
105. You can't communicate complexity, only an awareness of it.
47. As Will Rogers would have said, "There is no such thing as a free variable."
7. It is easier to write an incorrect program than understand a correct one.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
115. Most people find the concept of programming obvious, but the doing impossible.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
115. Most people find the concept of programming obvious, but the doing impossible.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
12. Recursion is the root of computation since it trades description for time.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
112. Computer Science is embarrassed by the computer.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
43. In software systems, it is often the early bird that makes the worm.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
3. Syntactic sugar causes cancer of the semicolon.
1. One man's constant is another man's variable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
90. Computation has made the tree flower.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
43. In software systems, it is often the early bird that makes the worm.
95. Don't have good ideas if you aren't willing to be responsible for them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
110. Editing is a rewording activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
22. A good system can't have a weak command language.
22. A good system can't have a weak command language.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
108. Whenever two programmers meet to criticize their programs, both are silent.
110. Editing is a rewording activity.
119. Programming is an unnatural act.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
11. If you have a procedure with ten parameters, you probably missed some.
57. It is easier to change the specification to fit the program than vice versa.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
105. You can't communicate complexity, only an awareness of it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
31. Simplicity does not precede complexity, but follows it.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
4. Every program is a part of some other program and rarely fits.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
4. Every program is a part of some other program and rarely fits.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
112. Computer Science is embarrassed by the computer.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
46. Like punning, programming is a play on words.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
27. Once you understand how to write a program get someone else to write it.
63. When we write programs that "learn", it turns out that we do and they don't.
22. A good system can't have a weak command language.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
111. Why did the Roman Empire collapse? What is Latin for office automation?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
47. As Will Rogers would have said, "There is no such thing as a free variable."
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
63. When we write programs that "learn", it turns out that we do and they don't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
57. It is easier to change the specification to fit the program than vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
8. A programming language is low level when its programs require attention to the irrelevant.
57. It is easier to change the specification to fit the program than vice versa.
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
1. One man's constant is another man's variable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
14. In the long run every program becomes rococo - then rubble.
104. The proof of a system's value is its existence.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
8. A programming language is low level when its programs require attention to the irrelevant.
96. Computers don't introduce order anywhere as much as they expose opportunities.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
62. In computing, invariants are ephemeral.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
96. Computers don't introduce order anywhere as much as they expose opportunities.
111. Why did the Roman Empire collapse? What is Latin for office automation?
46. Like punning, programming is a play on words.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
79. A year spent in artificial intelligence is enough to make one believe in God.
23. To understand a program you must become both the machine and the program.
76. It is the user who should parameterize procedures, not their creators.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
119. Programming is an unnatural act.
40. There are two ways to write error-free programs; only the third one works.
95. Don't have good ideas if you aren't willing to be responsible for them.
55. A LISP programmer knows the value of everything, but the cost of nothing.
66. Making something variable is easy. Controlling duration of constancy is the trick.
7. It is easier to write an incorrect program than understand a correct one.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
38. Structured Programming supports the law of the excluded middle.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
1. One man's constant is another man's variable.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
114. Within a computer natural language is unnatural.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
95. Don't have good ideas if you aren't willing to be responsible for them.
40. There are two ways to write error-free programs; only the third one works.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
98. In computing, the mean time to failure keeps getting shorter.
110. Editing is a rewording activity.
14. In the long run every program becomes rococo - then rubble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
108. Whenever two programmers meet to criticize their programs, both are silent.
15. Everything should be built top-down, except the first time.
11. If you have a procedure with ten parameters, you probably missed some.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
17. If a listener nods his head when you're explaining your program, wake him up.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
59. In English every word can be verbed. Would that it were so in our programming languages.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
61. In programming, as in everything else, to be in error is to be reborn.
8. A programming language is low level when its programs require attention to the irrelevant.
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
108. Whenever two programmers meet to criticize their programs, both are silent.
55. A LISP programmer knows the value of everything, but the cost of nothing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
8. A programming language is low level when its programs require attention to the irrelevant.
11. If you have a procedure with ten parameters, you probably missed some.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
21. Optimization hinders evolution.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
8. A programming language is low level when its programs require attention to the irrelevant.
31. Simplicity does not precede complexity, but follows it.
78. If your computer speaks English, it was probably made in Japan.
111. Why did the Roman Empire collapse? What is Latin for office automation?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
12. Recursion is the root of computation since it trades description for time.
59. In English every word can be verbed. Would that it were so in our programming languages.
43. In software systems, it is often the early bird that makes the worm.
112. Computer Science is embarrassed by the computer.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
115. Most people find the concept of programming obvious, but the doing impossible.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
.
115,760c
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
76. It is the user who should parameterize procedures, not their creators.
63. When we write programs that "learn", it turns out that we do and they don't.
4. Every program is a part of some other program and rarely fits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
103. Purely applicative languages are poorly applicable.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
55. A LISP programmer knows the value of everything, but the cost of nothing.
62. In computing, invariants are ephemeral.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
15. Everything should be built top-down, except the first time.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
61. In programming, as in everything else, to be in error is to be reborn.
12. Recursion is the root of computation since it trades description for time.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
4. Every program is a part of some other program and rarely fits.
72. An adequate bootstrap is a contradiction in terms.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
62. In computing, invariants are ephemeral.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
4. Every program is a part of some other program and rarely fits.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
15. Everything should be built top-down, except the first time.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
14. In the long run every program becomes rococo - then rubble.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
38. Structured Programming supports the law of the excluded middle.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
17. If a listener nods his head when you're explaining your program, wake him up.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
8. A programming language is low level when its programs require attention to the irrelevant.
114. Within a computer natural language is unnatural.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
38. Structured Programming supports the law of the excluded middle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
21. Optimization hinders evolution.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
4. Every program is a part of some other program and rarely fits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
66. Making something variable is easy. Controlling duration of constancy is the trick.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
119. Programming is an unnatural act.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
21. Optimization hinders evolution.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
119. Programming is an unnatural act.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
57. It is easier to change the specification to fit the program than vice versa.
102. One can't proceed from the informal to the formal by formal means.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
63. When we write programs that "learn", it turns out that we do and they don't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
62. In computing, invariants are ephemeral.
41. Some programming languages manage to absorb change, but withstand progress.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
78. If your computer speaks English, it was probably made in Japan.
31. Simplicity does not precede complexity, but follows it.
114. Within a computer natural language is unnatural.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
72. An adequate bootstrap is a contradiction in terms.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
95. Don't have good ideas if you aren't willing to be responsible for them.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
47. As Will Rogers would have said, "There is no such thing as a free variable."
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
14. In the long run every program becomes rococo - then rubble.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
38. Structured Programming supports the law of the excluded middle.
15. Everything should be built top-down, except the first time.
78. If your computer speaks English, it was probably made in Japan.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
18. A program without a loop and a structured variable isn't worth writing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
111. Why did the Roman Empire collapse? What is Latin for office automation?
114. Within a computer natural language is unnatural.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
62. In computing, invariants are ephemeral.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
76. It is the user who should parameterize procedures, not their creators.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
76. It is the user who should parameterize procedures, not their creators.
21. Optimization hinders evolution.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
62. In computing, invariants are ephemeral.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
78. If your computer speaks English, it was probably made in Japan.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
57. It is easier to change the specification to fit the program than vice versa.
47. As Will Rogers would have said, "There is no such thing as a free variable."
22. A good system can't have a weak command language.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
1. One man's constant is another man's variable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
1. One man's constant is another man's variable.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
119. Programming is an unnatural act.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
55. A LISP programmer knows the value of everything, but the cost of nothing.
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
60. In seeking the unattainable, simplicity only gets in the way.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
100. We will never run out of things to program as long as there is a single program around.
72. An adequate bootstrap is a contradiction in terms.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
63. When we write programs that "learn", it turns out that we do and they don't.
61. In programming, as in everything else, to be in error is to be reborn.
96. Computers don't introduce order anywhere as much as they expose opportunities.
76. It is the user who should parameterize procedures, not their creators.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
8. A programming language is low level when its programs require attention to the irrelevant.
108. Whenever two programmers meet to criticize their programs, both are silent.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
7. It is easier to write an incorrect program than understand a correct one.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
96. Computers don't introduce order anywhere as much as they expose opportunities.
57. It is easier to change the specification to fit the program than vice versa.
12. Recursion is the root of computation since it trades description for time.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
23. To understand a program you must become both the machine and the program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
103. Purely applicative languages are poorly applicable.
27. Once you understand how to write a program get someone else to write it.
27. Once you understand how to write a program get someone else to write it.
40. There are two ways to write error-free programs; only the third one works.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
100. We will never run out of things to program as long as there is a single program around.
57. It is easier to change the specification to fit the program than vice versa.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
63. When we write programs that "learn", it turns out that we do and they don't.
43. In software systems, it is often the early bird that makes the worm.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
12. Recursion is the root of computation since it trades description for time.
95. Don't have good ideas if you aren't willing to be responsible for them.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
1. One man's constant is another man's variable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
104. The proof of a system's value is its existence.
3. Syntactic sugar causes cancer of the semicolon.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
72. An adequate bootstrap is a contradiction in terms.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
90. Computation has made the tree flower.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
60. In seeking the unattainable, simplicity only gets in the way.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
63. When we write programs that "learn", it turns out that we do and they don't.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
66. Making something variable is easy. Controlling duration of constancy is the trick.
102. One can't proceed from the informal to the formal by formal means.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
46. Like punning, programming is a play on words.
43. In software systems, it is often the early bird that makes the worm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
110. Editing is a rewording activity.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
102. One can't proceed from the informal to the formal by formal means.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
43. In software systems, it is often the early bird that makes the worm.
95. Don't have good ideas if you aren't willing to be responsible for them.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
59. In English every word can be verbed. Would that it were so in our programming languages.
96. Computers don't introduce order anywhere as much as they expose opportunities.
14. In the long run every program becomes rococo - then rubble.
60. In seeking the unattainable, simplicity only gets in the way.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
78. If your computer speaks English, it was probably made in Japan.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
98. In computing, the mean time to failure keeps getting shorter.
111. Why did the Roman Empire collapse? What is Latin for office automation?
27. Once you understand how to write a program get someone else to write it.
108. Whenever two programmers meet to criticize their programs, both are silent.
8. A programming language is low level when its programs require attention to the irrelevant.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
111. Why did the Roman Empire collapse? What is Latin for office automation?
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
115. Most people find the concept of programming obvious, but the doing impossible.
62. In computing, invariants are ephemeral.
8. A programming language is low level when its programs require attention to the irrelevant.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
12. Recursion is the root of computation since it trades description for time.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
11. If you have a procedure with ten parameters, you probably missed some.
23. To understand a program you must become both the machine and the program.
8. A programming language is low level when its programs require attention to the irrelevant.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
78. If your computer speaks English, it was probably made in Japan.
79. A year spent in artificial intelligence is enough to make one believe in God.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
22. A good system can't have a weak command language.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
114. Within a computer natural language is unnatural.
7. It is easier to write an incorrect program than understand a correct one.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
11. If you have a procedure with ten parameters, you probably missed some.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
61. In programming, as in everything else, to be in error is to be reborn.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
17. If a listener nods his head when you're explaining your program, wake him up.
104. The proof of a system's value is its existence.
4. Every program is a part of some other program and rarely fits.
112. Computer Science is embarrassed by the computer.
60. In seeking the unattainable, simplicity only gets in the way.
111. Why did the Roman Empire collapse? What is Latin for office automation?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
96. Computers don't introduce order anywhere as much as they expose opportunities.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
15. Everything should be built top-down, except the first time.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
18. A program without a loop and a structured variable isn't worth writing.
17. If a listener nods his head when you're explaining your program, wake him up.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
115. Most people find the concept of programming obvious, but the doing impossible.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
79. A year spent in artificial intelligence is enough to make one believe in God.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
61. In programming, as in everything else, to be in error is to be reborn.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
62. In computing, invariants are ephemeral.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
23. To understand a program you must become both the machine and the program.
12. Recursion is the root of computation since it trades description for time.
104. The proof of a system's value is its existence.
4. Every program is a part of some other program and rarely fits.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
1. One man's constant is another man's variable.
61. In programming, as in everything else, to be in error is to be reborn.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
57. It is easier to change the specification to fit the program than vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
61. In programming, as in everything else, to be in error is to be reborn.
43. In software systems, it is often the early bird that makes the worm.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
115. Most people find the concept of programming obvious, but the doing impossible.
98. In computing, the mean time to failure keeps getting shorter.
105. You can't communicate complexity, only an awareness of it.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
95. Don't have good ideas if you aren't willing to be responsible for them.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
17. If a listener nods his head when you're explaining your program, wake him up.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
41. Some programming languages manage to absorb change, but withstand progress.
62. In computing, invariants are ephemeral.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
112. Computer Science is embarrassed by the computer.
115. Most people find the concept of programming obvious, but the doing impossible.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
119. Programming is an unnatural act.
3. Syntactic sugar causes cancer of the semicolon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
72. An adequate bootstrap is a contradiction in terms.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
23. To understand a program you must become both the machine and the program.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
43. In software systems, it is often the early bird that makes the worm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
90. Computation has made the tree flower.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
3. Syntactic sugar causes cancer of the semicolon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
95. Don't have good ideas if you aren't willing to be responsible for them.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
22. A good system can't have a weak command language.
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
21. Optimization hinders evolution.
27. Once you understand how to write a program get someone else to write it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
79. A year spent in artificial intelligence is enough to make one believe in God.
14. In the long run every program becomes rococo - then rubble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
38. Structured Programming supports the law of the excluded middle.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
57. It is easier to change the specification to fit the program than vice versa.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
114. Within a computer natural language is unnatural.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
60. In seeking the unattainable, simplicity only gets in the way.
7. It is easier to write an incorrect program than understand a correct one.
112. Computer Science is embarrassed by the computer.
14. In the long run every program becomes rococo - then rubble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
15. Everything should be built top-down, except the first time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
105. You can't communicate complexity, only an awareness of it.
108. Whenever two programmers meet to criticize their programs, both are silent.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
31. Simplicity does not precede complexity, but follows it.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
98. In computing, the mean time to failure keeps getting shorter.
78. If your computer speaks English, it was probably made in Japan.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
27. Once you understand how to write a program get someone else to write it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
110. Editing is a rewording activity.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
4. Every program is a part of some other program and rarely fits.
.
405,556d
828,937p
144,188c
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
79. A year spent in artificial intelligence is enough to make one believe in God.
78. If your computer speaks English, it was probably made in Japan.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
112. Computer Science is embarrassed by the computer.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
11. If you have a procedure with ten parameters, you probably missed some.
47. As Will Rogers would have said, "There is no such thing as a free variable."
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
31. Simplicity does not precede complexity, but follows it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
40. There are two ways to write error-free programs; only the third one works.
43. In software systems, it is often the early bird that makes the worm.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
22. A good system can't have a weak command language.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
57. It is easier to change the specification to fit the program than vice versa.
72. An adequate bootstrap is a contradiction in terms.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
8. A programming language is low level when its programs require attention to the irrelevant.
14. In the long run every program becomes rococo - then rubble.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
7. It is easier to write an incorrect program than understand a correct one.
.
978,1002d
570,702d
835,911p
226,976d
224,513c
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
12. Recursion is the root of computation since it trades description for time.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
4. Every program is a part of some other program and rarely fits.
66. Making something variable is easy. Controlling duration of constancy is the trick.
12. Recursion is the root of computation since it trades description for time.
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
79. A year spent in artificial intelligence is enough to make one believe in God.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
103. Purely applicative languages are poorly applicable.
98. In computing, the mean time to failure keeps getting shorter.
104. The proof of a system's value is its existence.
47. As Will Rogers would have said, "There is no such thing as a free variable."
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
108. Whenever two programmers meet to criticize their programs, both are silent.
78. If your computer speaks English, it was probably made in Japan.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
22. A good system can't have a weak command language.
21. Optimization hinders evolution.
31. Simplicity does not precede complexity, but follows it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
11. If you have a procedure with ten parameters, you probably missed some.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
96. Computers don't introduce order anywhere as much as they expose opportunities.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
4. Every program is a part of some other program and rarely fits.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
41. Some programming languages manage to absorb change, but withstand progress.
63. When we write programs that "learn", it turns out that we do and they don't.
23. To understand a program you must become both the machine and the program.
4. Every program is a part of some other program and rarely fits.
38. Structured Programming supports the law of the excluded middle.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
104. The proof of a system's value is its existence.
59. In English every word can be verbed. Would that it were so in our programming languages.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
43. In software systems, it is often the early bird that makes the worm.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
114. Within a computer natural language is unnatural.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
40. There are two ways to write error-free programs; only the third one works.
31. Simplicity does not precede complexity, but follows it.
108. Whenever two programmers meet to criticize their programs, both are silent.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
38. Structured Programming supports the law of the excluded middle.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
61. In programming, as in everything else, to be in error is to be reborn.
11. If you have a procedure with ten parameters, you probably missed some.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
1. One man's constant is another man's variable.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
38. Structured Programming supports the law of the excluded middle.
104. The proof of a system's value is its existence.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
27. Once you understand how to write a program get someone else to write it.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
40. There are two ways to write error-free programs; only the third one works.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
63. When we write programs that "learn", it turns out that we do and they don't.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
115. Most people find the concept of programming obvious, but the doing impossible.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
7. It is easier to write an incorrect program than understand a correct one.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
1. One man's constant is another man's variable.
40. There are two ways to write error-free programs; only the third one works.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
17. If a listener nods his head when you're explaining your program, wake him up.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
100. We will never run out of things to program as long as there is a single program around.
111. Why did the Roman Empire collapse? What is Latin for office automation?
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
43. In software systems, it is often the early bird that makes the worm.
78. If your computer speaks English, it was probably made in Japan.
100. We will never run out of things to program as long as there is a single program around.
43. In software systems, it is often the early bird that makes the worm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
43. In software systems, it is often the early bird that makes the worm.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
17. If a listener nods his head when you're explaining your program, wake him up.
96. Computers don't introduce order anywhere as much as they expose opportunities.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
102. One can't proceed from the informal to the formal by formal means.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
41. Some programming languages manage to absorb change, but withstand progress.
46. Like punning, programming is a play on words.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
115. Most people find the concept of programming obvious, but the doing impossible.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
59. In English every word can be verbed. Would that it were so in our programming languages.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
63. When we write programs that "learn", it turns out that we do and they don't.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
66. Making something variable is easy. Controlling duration of constancy is the trick.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
47. As Will Rogers would have said, "There is no such thing as a free variable."
107. The debate rages on: is PL/I Bachtrian or Dromedary?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
100. We will never run out of things to program as long as there is a single program around.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
95. Don't have good ideas if you aren't willing to be responsible for them.
100. We will never run out of things to program as long as there is a single program around.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
47. As Will Rogers would have said, "There is no such thing as a free variable."
15. Everything should be built top-down, except the first time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
90. Computation has made the tree flower.
17. If a listener nods his head when you're explaining your program, wake him up.
72. An adequate bootstrap is a contradiction in terms.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
112. Computer Science is embarrassed by the computer.
31. Simplicity does not precede complexity, but follows it.
41. Some programming languages manage to absorb change, but withstand progress.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
112. Computer Science is embarrassed by the computer.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
23. To understand a program you must become both the machine and the program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
55. A LISP programmer knows the value of everything, but the cost of nothing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
103. Purely applicative languages are poorly applicable.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
47. As Will Rogers would have said, "There is no such thing as a free variable."
103. Purely applicative languages are poorly applicable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
3. Syntactic sugar causes cancer of the semicolon.
60. In seeking the unattainable, simplicity only gets in the way.
23. To understand a program you must become both the machine and the program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
63. When we write programs that "learn", it turns out that we do and they don't.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
102. One can't proceed from the informal to the formal by formal means.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
18. A program without a loop and a structured variable isn't worth writing.
90. Computation has made the tree flower.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
15. Everything should be built top-down, except the first time.
100. We will never run out of things to program as long as there is a single program around.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
62. In computing, invariants are ephemeral.
31. Simplicity does not precede complexity, but follows it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
76. It is the user who should parameterize procedures, not their creators.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
57. It is easier to change the specification to fit the program than vice versa.
103. Purely applicative languages are poorly applicable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
7. It is easier to write an incorrect program than understand a correct one.
38. Structured Programming supports the law of the excluded middle.
76. It is the user who should parameterize procedures, not their creators.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
12. Recursion is the root of computation since it trades description for time.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
62. In computing, invariants are ephemeral.
.
371,556c
90. Computation has made the tree flower.
96. Computers don't introduce order anywhere as much as they expose opportunities.
119. Programming is an unnatural act.
72. An adequate bootstrap is a contradiction in terms.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
23. To understand a program you must become both the machine and the program.
100. We will never run out of things to program as long as there is a single program around.
40. There are two ways to write error-free programs; only the third one works.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
111. Why did the Roman Empire collapse? What is Latin for office automation?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
104. The proof of a system's value is its existence.
61. In programming, as in everything else, to be in error is to be reborn.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
103. Purely applicative languages are poorly applicable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
72. An adequate bootstrap is a contradiction in terms.
31. Simplicity does not precede complexity, but follows it.
12. Recursion is the root of computation since it trades description for time.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
78. If your computer speaks English, it was probably made in Japan.
23. To understand a program you must become both the machine and the program.
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
72. An adequate bootstrap is a contradiction in terms.
43. In software systems, it is often the early bird that makes the worm.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
115. Most people find the concept of programming obvious, but the doing impossible.
41. Some programming languages manage to absorb change, but withstand progress.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
110. Editing is a rewording activity.
61. In programming, as in everything else, to be in error is to be reborn.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
103. Purely applicative languages are poorly applicable.
12. Recursion is the root of computation since it trades description for time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
31. Simplicity does not precede complexity, but follows it.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
66. Making something variable is easy. Controlling duration of constancy is the trick.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
102. One can't proceed from the informal to the formal by formal means.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
17. If a listener nods his head when you're explaining your program, wake him up.
3. Syntactic sugar causes cancer of the semicolon.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
8. A programming language is low level when its programs require attention to the irrelevant.
66. Making something variable is easy. Controlling duration of constancy is the trick.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
43. In software systems, it is often the early bird that makes the worm.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
115. Most people find the concept of programming obvious, but the doing impossible.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
108. Whenever two programmers meet to criticize their programs, both are silent.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
17. If a listener nods his head when you're explaining your program, wake him up.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
63. When we write programs that "learn", it turns out that we do and they don't.
100. We will never run out of things to program as long as there is a single program around.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
100. We will never run out of things to program as long as there is a single program around.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
41. Some programming languages manage to absorb change, but withstand progress.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
105. You can't communicate complexity, only an awareness of it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
57. It is easier to change the specification to fit the program than vice versa.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
96. Computers don't introduce order anywhere as much as they expose opportunities.
22. A good system can't have a weak command language.
14. In the long run every program becomes rococo - then rubble.
112. Computer Science is embarrassed by the computer.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
95. Don't have good ideas if you aren't willing to be responsible for them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
95. Don't have good ideas if you aren't willing to be responsible for them.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
59. In English every word can be verbed. Would that it were so in our programming languages.
105. You can't communicate complexity, only an awareness of it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
57. It is easier to change the specification to fit the program than vice versa.
61. In programming, as in everything else, to be in error is to be reborn.
17. If a listener nods his head when you're explaining your program, wake him up.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
114. Within a computer natural language is unnatural.
14. In the long run every program becomes rococo - then rubble.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
111. Why did the Roman Empire collapse? What is Latin for office automation?
43. In software systems, it is often the early bird that makes the worm.
98. In computing, the mean time to failure keeps getting shorter.
11. If you have a procedure with ten parameters, you probably missed some.
40. There are two ways to write error-free programs; only the third one works.
3. Syntactic sugar causes cancer of the semicolon.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
110. Editing is a rewording activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
40. There are two ways to write error-free programs; only the third one works.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
3. Syntactic sugar causes cancer of the semicolon.
111. Why did the Roman Empire collapse? What is Latin for office automation?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
78. If your computer speaks English, it was probably made in Japan.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
105. You can't communicate complexity, only an awareness of it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
47. As Will Rogers would have said, "There is no such thing as a free variable."
104. The proof of a system's value is its existence.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
114. Within a computer natural language is unnatural.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
.
641,753d
486,820c
40. There are two ways to write error-free programs; only the third one works.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
8. A programming language is low level when its programs require attention to the irrelevant.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
103. Purely applicative languages are poorly applicable.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
110. Editing is a rewording activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
38. Structured Programming supports the law of the excluded middle.
38. Structured Programming supports the law of the excluded middle.
108. Whenever two programmers meet to criticize their programs, both are silent.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
8. A programming language is low level when its programs require attention to the irrelevant.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
78. If your computer speaks English, it was probably made in Japan.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
46. Like punning, programming is a play on words.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
76. It is the user who should parameterize procedures, not their creators.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
38. Structured Programming supports the law of the excluded middle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
90. Computation has made the tree flower.
47. As Will Rogers would have said, "There is no such thing as a free variable."
23. To understand a program you must become both the machine and the program.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
23. To understand a program you must become both the machine and the program.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
55. A LISP programmer knows the value of everything, but the cost of nothing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
8. A programming language is low level when its programs require attention to the irrelevant.
111. Why did the Roman Empire collapse? What is Latin for office automation?
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
79. A year spent in artificial intelligence is enough to make one believe in God.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
95. Don't have good ideas if you aren't willing to be responsible for them.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
46. Like punning, programming is a play on words.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
111. Why did the Roman Empire collapse? What is Latin for office automation?
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
119. Programming is an unnatural act.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
8. A programming language is low level when its programs require attention to the irrelevant.
21. Optimization hinders evolution.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
60. In seeking the unattainable, simplicity only gets in the way.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
41. Some programming languages manage to absorb change, but withstand progress.
90. Computation has made the tree flower.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
1. One man's constant is another man's variable.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
3. Syntactic sugar causes cancer of the semicolon.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
21. Optimization hinders evolution.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
119. Programming is an unnatural act.
41. Some programming languages manage to absorb change, but withstand progress.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
18. A program without a loop and a structured variable isn't worth writing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
1. One man's constant is another man's variable.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
12. Recursion is the root of computation since it trades description for time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
7. It is easier to write an incorrect program than understand a correct one.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
63. When we write programs that "learn", it turns out that we do and they don't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
43. In software systems, it is often the early bird that makes the worm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
104. The proof of a system's value is its existence.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
115. Most people find the concept of programming obvious, but the doing impossible.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
55. A LISP programmer knows the value of everything, but the cost of nothing.
100. We will never run out of things to program as long as there is a single program around.
55. A LISP programmer knows the value of everything, but the cost of nothing.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
23. To understand a program you must become both the machine and the program.
3. Syntactic sugar causes cancer of the semicolon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
104. The proof of a system's value is its existence.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
21. Optimization hinders evolution.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
59. In English every word can be verbed. Would that it were so in our programming languages.
17. If a listener nods his head when you're explaining your program, wake him up.
66. Making something variable is easy. Controlling duration of constancy is the trick.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
15. Everything should be built top-down, except the first time.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
112. Computer Science is embarrassed by the computer.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
14. In the long run every program becomes rococo - then rubble.
61. In programming, as in everything else, to be in error is to be reborn.
12. Recursion is the root of computation since it trades description for time.
108. Whenever two programmers meet to criticize their programs, both are silent.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
23. To understand a program you must become both the machine and the program.
111. Why did the Roman Empire collapse? What is Latin for office automation?
8. A programming language is low level when its programs require attention to the irrelevant.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
95. Don't have good ideas if you aren't willing to be responsible for them.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
4. Every program is a part of some other program and rarely fits.
3. Syntactic sugar causes cancer of the semicolon.
112. Computer Science is embarrassed by the computer.
3. Syntactic sugar causes cancer of the semicolon.
103. Purely applicative languages are poorly applicable.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
119. Programming is an unnatural act.
27. Once you understand how to write a program get someone else to write it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
62. In computing, invariants are ephemeral.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
108. Whenever two programmers meet to criticize their programs, both are silent.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
18. A program without a loop and a structured variable isn't worth writing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
105. You can't communicate complexity, only an awareness of it.
27. Once you understand how to write a program get someone else to write it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
1. One man's constant is another man's variable.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
11. If you have a procedure with ten parameters, you probably missed some.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
46. Like punning, programming is a play on words.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
76. It is the user who should parameterize procedures, not their creators.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
38. Structured Programming supports the law of the excluded middle.
8. A programming language is low level when its programs require attention to the irrelevant.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
41. Some programming languages manage to absorb change, but withstand progress.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
59. In English every word can be verbed. Would that it were so in our programming languages.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
66. Making something variable is easy. Controlling duration of constancy is the trick.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
14. In the long run every program becomes rococo - then rubble.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
55. A LISP programmer knows the value of everything, but the cost of nothing.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
72. An adequate bootstrap is a contradiction in terms.
27. Once you understand how to write a program get someone else to write it.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
90. Computation has made the tree flower.
79. A year spent in artificial intelligence is enough to make one believe in God.
104. The proof of a system's value is its existence.
17. If a listener nods his head when you're explaining your program, wake him up.
59. In English every word can be verbed. Would that it were so in our programming languages.
23. To understand a program you must become both the machine and the program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
59. In English every word can be verbed. Would that it were so in our programming languages.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
38. Structured Programming supports the law of the excluded middle.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
47. As Will Rogers would have said, "There is no such thing as a free variable."
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
111. Why did the Roman Empire collapse? What is Latin for office automation?
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
15. Everything should be built top-down, except the first time.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
111. Why did the Roman Empire collapse? What is Latin for office automation?
78. If your computer speaks English, it was probably made in Japan.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
40. There are two ways to write error-free programs; only the third one works.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
40. There are two ways to write error-free programs; only the third one works.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
119. Programming is an unnatural act.
100. We will never run out of things to program as long as there is a single program around.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
62. In computing, invariants are ephemeral.
4. Every program is a part of some other program and rarely fits.
31. Simplicity does not precede complexity, but follows it.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
21. Optimization hinders evolution.
41. Some programming languages manage to absorb change, but withstand progress.
79. A year spent in artificial intelligence is enough to make one believe in God.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
14. In the long run every program becomes rococo - then rubble.
98. In computing, the mean time to failure keeps getting shorter.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
98. In computing, the mean time to failure keeps getting shorter.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
102. One can't proceed from the informal to the formal by formal means.
38. Structured Programming supports the law of the excluded middle.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
23. To understand a program you must become both the machine and the program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
27. Once you understand how to write a program get someone else to write it.
4. Every program is a part of some other program and rarely fits.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
8. A programming language is low level when its programs require attention to the irrelevant.
27. Once you understand how to write a program get someone else to write it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
.
194,606d
748,974d
110,608d
949,950d
31,920d
736,773d
874,1011p
19,588c
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
100. We will never run out of things to program as long as there is a single program around.
61. In programming, as in everything else, to be in error is to be reborn.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
62. In computing, invariants are ephemeral.
21. Optimization hinders evolution.
104. The proof of a system's value is its existence.
61. In programming, as in everything else, to be in error is to be reborn.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
111. Why did the Roman Empire collapse? What is Latin for office automation?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
107. The debate rages on: is PL/I Bachtrian or Dromedary?
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
18. A program without a loop and a structured variable isn't worth writing.
98. In computing, the mean time to failure keeps getting shorter.
15. Everything should be built top-down, except the first time.
76. It is the user who should parameterize procedures, not their creators.
100. We will never run out of things to program as long as there is a single program around.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
57. It is easier to change the specification to fit the program than vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
76. It is the user who should parameterize procedures, not their creators.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
21. Optimization hinders evolution.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
108. Whenever two programmers meet to criticize their programs, both are silent.
90. Computation has made the tree flower.
12. Recursion is the root of computation since it trades description for time.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
76. It is the user who should parameterize procedures, not their creators.
1. One man's constant is another man's variable.
103. Purely applicative languages are poorly applicable.
63. When we write programs that "learn", it turns out that we do and they don't.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
110. Editing is a rewording activity.
21. Optimization hinders evolution.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
115. Most people find the concept of programming obvious, but the doing impossible.
62. In computing, invariants are ephemeral.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
3. Syntactic sugar causes cancer of the semicolon.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
40. There are two ways to write error-free programs; only the third one works.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
72. An adequate bootstrap is a contradiction in terms.
72. An adequate bootstrap is a contradiction in terms.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
104. The proof of a system's value is its existence.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
59. In English every word can be verbed. Would that it were so in our programming languages.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
110. Editing is a rewording activity.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
11. If you have a procedure with ten parameters, you probably missed some.
11. If you have a procedure with ten parameters, you probably missed some.
66. Making something variable is easy. Controlling duration of constancy is the trick.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
60. In seeking the unattainable, simplicity only gets in the way.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
108. Whenever two programmers meet to criticize their programs, both are silent.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
1. One man's constant is another man's variable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
62. In computing, invariants are ephemeral.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
72. An adequate bootstrap is a contradiction in terms.
72. An adequate bootstrap is a contradiction in terms.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
90. Computation has made the tree flower.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
79. A year spent in artificial intelligence is enough to make one believe in God.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
7. It is easier to write an incorrect program than understand a correct one.
47. As Will Rogers would have said, "There is no such thing as a free variable."
72. An adequate bootstrap is a contradiction in terms.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
79. A year spent in artificial intelligence is enough to make one believe in God.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
4. Every program is a part of some other program and rarely fits.
108. Whenever two programmers meet to criticize their programs, both are silent.
21. Optimization hinders evolution.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
96. Computers don't introduce order anywhere as much as they expose opportunities.
59. In English every word can be verbed. Would that it were so in our programming languages.
112. Computer Science is embarrassed by the computer.
72. An adequate bootstrap is a contradiction in terms.
1. One man's constant is another man's variable.
8. A programming language is low level when its programs require attention to the irrelevant.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
98. In computing, the mean time to failure keeps getting shorter.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
76. It is the user who should parameterize procedures, not their creators.
14. In the long run every program becomes rococo - then rubble.
22. A good system can't have a weak command language.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
27. Once you understand how to write a program get someone else to write it.
57. It is easier to change the specification to fit the program than vice versa.
105. You can't communicate complexity, only an awareness of it.
61. In programming, as in everything else, to be in error is to be reborn.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
15. Everything should be built top-down, except the first time.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
31. Simplicity does not precede complexity, but follows it.
79. A year spent in artificial intelligence is enough to make one believe in God.
27. Once you understand how to write a program get someone else to write it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
41. Some programming languages manage to absorb change, but withstand progress.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
23. To understand a program you must become both the machine and the program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
11. If you have a procedure with ten parameters, you probably missed some.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
103. Purely applicative languages are poorly applicable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
1. One man's constant is another man's variable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
66. Making something variable is easy. Controlling duration of constancy is the trick.
72. An adequate bootstrap is a contradiction in terms.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
76. It is the user who should parameterize procedures, not their creators.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
22. A good system can't have a weak command language.
78. If your computer speaks English, it was probably made in Japan.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
110. Editing is a rewording activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
57. It is easier to change the specification to fit the program than vice versa.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
1. One man's constant is another man's variable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
90. Computation has made the tree flower.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
40. There are two ways to write error-free programs; only the third one works.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
60. In seeking the unattainable, simplicity only gets in the way.
15. Everything should be built top-down, except the first time.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
15. Everything should be built top-down, except the first time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
72. An adequate bootstrap is a contradiction in terms.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
108. Whenever two programmers meet to criticize their programs, both are silent.
40. There are two ways to write error-free programs; only the third one works.
4. Every program is a part of some other program and rarely fits.
114. Within a computer natural language is unnatural.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
38. Structured Programming supports the law of the excluded middle.
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
21. Optimization hinders evolution.
7. It is easier to write an incorrect program than understand a correct one.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
22. A good system can't have a weak command language.
57. It is easier to change the specification to fit the program than vice versa.
104. The proof of a system's value is its existence.
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
114. Within a computer natural language is unnatural.
3. Syntactic sugar causes cancer of the semicolon.
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
43. In software systems, it is often the early bird that makes the worm.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
108. Whenever two programmers meet to criticize their programs, both are silent.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
72. An adequate bootstrap is a contradiction in terms.
11. If you have a procedure with ten parameters, you probably missed some.
78. If your computer speaks English, it was probably made in Japan.
40. There are two ways to write error-free programs; only the third one works.
41. Some programming languages manage to absorb change, but withstand progress.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
1. One man's constant is another man's variable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
72. An adequate bootstrap is a contradiction in terms.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
27. Once you understand how to write a program get someone else to write it.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
23. To understand a program you must become both the machine and the program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
79. A year spent in artificial intelligence is enough to make one believe in God.
55. A LISP programmer knows the value of everything, but the cost of nothing.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
21. Optimization hinders evolution.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
46. Like punning, programming is a play on words.
119. Programming is an unnatural act.
43. In software systems, it is often the early bird that makes the worm.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
62. In computing, invariants are ephemeral.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
8. A programming language is low level when its programs require attention to the irrelevant.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
105. You can't communicate complexity, only an awareness of it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
11. If you have a procedure with ten parameters, you probably missed some.
57. It is easier to change the specification to fit the program than vice versa.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
105. You can't communicate complexity, only an awareness of it.
8. A programming language is low level when its programs require attention to the irrelevant.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
21. Optimization hinders evolution.
62. In computing, invariants are ephemeral.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
18. A program without a loop and a structured variable isn't worth writing.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
102. One can't proceed from the informal to the formal by formal means.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
100. We will never run out of things to program as long as there is a single program around.
57. It is easier to change the specification to fit the program than vice versa.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
40. There are two ways to write error-free programs; only the third one works.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
115. Most people find the concept of programming obvious, but the doing impossible.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
40. There are two ways to write error-free programs; only the third one works.
103. Purely applicative languages are poorly applicable.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
63. When we write programs that "learn", it turns out that we do and they don't.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
4. Every program is a part of some other program and rarely fits.
15. Everything should be built top-down, except the first time.
41. Some programming languages manage to absorb change, but withstand progress.
7. It is easier to write an incorrect program than understand a correct one.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
57. It is easier to change the specification to fit the program than vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
12. Recursion is the root of computation since it trades description for time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
79. A year spent in artificial intelligence is enough to make one believe in God.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
59. In English every word can be verbed. Would that it were so in our programming languages.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
104. The proof of a system's value is its existence.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
40. There are two ways to write error-free programs; only the third one works.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
11. If you have a procedure with ten parameters, you probably missed some.
8. A programming language is low level when its programs require attention to the irrelevant.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
43. In software systems, it is often the early bird that makes the worm.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
15. Everything should be built top-down, except the first time.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
119. Programming is an unnatural act.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
23. To understand a program you must become both the machine and the program.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
104. The proof of a system's value is its existence.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
31. Simplicity does not precede complexity, but follows it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
27. Once you understand how to write a program get someone else to write it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
78. If your computer speaks English, it was probably made in Japan.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
102. One can't proceed from the informal to the formal by formal means.
8. A programming language is low level when its programs require attention to the irrelevant.
79. A year spent in artificial intelligence is enough to make one believe in God.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
62. In computing, invariants are ephemeral.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
100. We will never run out of things to program as long as there is a single program around.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
95. Don't have good ideas if you aren't willing to be responsible for them.
102. One can't proceed from the informal to the formal by formal means.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
55. A LISP programmer knows the value of everything, but the cost of nothing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
59. In English every word can be verbed. Would that it were so in our programming languages.
40. There are two ways to write error-free programs; only the third one works.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
115. Most people find the concept of programming obvious, but the doing impossible.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
103. Purely applicative languages are poorly applicable.
41. Some programming languages manage to absorb change, but withstand progress.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
115. Most people find the concept of programming obvious, but the doing impossible.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
78. If your computer speaks English, it was probably made in Japan.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
15. Everything should be built top-down, except the first time.
103. Purely applicative languages are poorly applicable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
22. A good system can't have a weak command language.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
22. A good system can't have a weak command language.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
112. Computer Science is embarrassed by the computer.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
1. One man's constant is another man's variable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
12. Recursion is the root of computation since it trades description for time.
112. Computer Science is embarrassed by the computer.
96. Computers don't introduce order anywhere as much as they expose opportunities.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
31. Simplicity does not precede complexity, but follows it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
18. A program without a loop and a structured variable isn't worth writing.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
57. It is easier to change the specification to fit the program than vice versa.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
17. If a listener nods his head when you're explaining your program, wake him up.
55. A LISP programmer knows the value of everything, but the cost of nothing.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
21. Optimization hinders evolution.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
31. Simplicity does not precede complexity, but follows it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
108. Whenever two programmers meet to criticize their programs, both are silent.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
.
858,892d
642,981d
376,523p
421,1007c
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
4. Every program is a part of some other program and rarely fits.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
47. As Will Rogers would have said, "There is no such thing as a free variable."
115. Most people find the concept of programming obvious, but the doing impossible.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
4. Every program is a part of some other program and rarely fits.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
7. It is easier to write an incorrect program than understand a correct one.
119. Programming is an unnatural act.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
100. We will never run out of things to program as long as there is a single program around.
108. Whenever two programmers meet to criticize their programs, both are silent.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
100. We will never run out of things to program as long as there is a single program around.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
112. Computer Science is embarrassed by the computer.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
11. If you have a procedure with ten parameters, you probably missed some.
102. One can't proceed from the informal to the formal by formal means.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
3. Syntactic sugar causes cancer of the semicolon.
22. A good system can't have a weak command language.
11. If you have a procedure with ten parameters, you probably missed some.
90. Computation has made the tree flower.
100. We will never run out of things to program as long as there is a single program around.
119. Programming is an unnatural act.
21. Optimization hinders evolution.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
27. Once you understand how to write a program get someone else to write it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
76. It is the user who should parameterize procedures, not their creators.
96. Computers don't introduce order anywhere as much as they expose opportunities.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
103. Purely applicative languages are poorly applicable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
62. In computing, invariants are ephemeral.
111. Why did the Roman Empire collapse? What is Latin for office automation?
100. We will never run out of things to program as long as there is a single program around.
100. We will never run out of things to program as long as there is a single program around.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
105. You can't communicate complexity, only an awareness of it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
14. In the long run every program becomes rococo - then rubble.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
105. You can't communicate complexity, only an awareness of it.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
90. Computation has made the tree flower.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
63. When we write programs that "learn", it turns out that we do and they don't.
59. In English every word can be verbed. Would that it were so in our programming languages.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
108. Whenever two programmers meet to criticize their programs, both are silent.
100. We will never run out of things to program as long as there is a single program around.
100. We will never run out of things to program as long as there is a single program around.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
7. It is easier to write an incorrect program than understand a correct one.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
3. Syntactic sugar causes cancer of the semicolon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
23. To understand a program you must become both the machine and the program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
78. If your computer speaks English, it was probably made in Japan.
103. Purely applicative languages are poorly applicable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
59. In English every word can be verbed. Would that it were so in our programming languages.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
100. We will never run out of things to program as long as there is a single program around.
98. In computing, the mean time to failure keeps getting shorter.
76. It is the user who should parameterize procedures, not their creators.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
114. Within a computer natural language is unnatural.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
72. An adequate bootstrap is a contradiction in terms.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
59. In English every word can be verbed. Would that it were so in our programming languages.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
104. The proof of a system's value is its existence.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
3. Syntactic sugar causes cancer of the semicolon.
7. It is easier to write an incorrect program than understand a correct one.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
38. Structured Programming supports the law of the excluded middle.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
72. An adequate bootstrap is a contradiction in terms.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
62. In computing, invariants are ephemeral.
12. Recursion is the root of computation since it trades description for time.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
47. As Will Rogers would have said, "There is no such thing as a free variable."
119. Programming is an unnatural act.
104. The proof of a system's value is its existence.
98. In computing, the mean time to failure keeps getting shorter.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
105. You can't communicate complexity, only an awareness of it.
98. In computing, the mean time to failure keeps getting shorter.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
43. In software systems, it is often the early bird that makes the worm.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
63. When we write programs that "learn", it turns out that we do and they don't.
47. As Will Rogers would have said, "There is no such thing as a free variable."
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
31. Simplicity does not precede complexity, but follows it.
38. Structured Programming supports the law of the excluded middle.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
15. Everything should be built top-down, except the first time.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
96. Computers don't introduce order anywhere as much as they expose opportunities.
112. Computer Science is embarrassed by the computer.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
104. The proof of a system's value is its existence.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
7. It is easier to write an incorrect program than understand a correct one.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
12. Recursion is the root of computation since it trades description for time.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
61. In programming, as in everything else, to be in error is to be reborn.
15. Everything should be built top-down, except the first time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
47. As Will Rogers would have said, "There is no such thing as a free variable."
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
66. Making something variable is easy. Controlling duration of constancy is the trick.
18. A program without a loop and a structured variable isn't worth writing.
100. We will never run out of things to program as long as there is a single program around.
17. If a listener nods his head when you're explaining your program, wake him up.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
17. If a listener nods his head when you're explaining your program, wake him up.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
105. You can't communicate complexity, only an awareness of it.
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
46. Like punning, programming is a play on words.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
78. If your computer speaks English, it was probably made in Japan.
119. Programming is an unnatural act.
114. Within a computer natural language is unnatural.
60. In seeking the unattainable, simplicity only gets in the way.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
1. One man's constant is another man's variable.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
7. It is easier to write an incorrect program than understand a correct one.
46. Like punning, programming is a play on words.
55. A LISP programmer knows the value of everything, but the cost of nothing.
102. One can't proceed from the informal to the formal by formal means.
78. If your computer speaks English, it was probably made in Japan.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
59. In English every word can be verbed. Would that it were so in our programming languages.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
27. Once you understand how to write a program get someone else to write it.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
11. If you have a procedure with ten parameters, you probably missed some.
98. In computing, the mean time to failure keeps getting shorter.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
22. A good system can't have a weak command language.
60. In seeking the unattainable, simplicity only gets in the way.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
4. Every program is a part of some other program and rarely fits.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
1. One man's constant is another man's variable.
114. Within a computer natural language is unnatural.
102. One can't proceed from the informal to the formal by formal means.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
105. You can't communicate complexity, only an awareness of it.
40. There are two ways to write error-free programs; only the third one works.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
11. If you have a procedure with ten parameters, you probably missed some.
78. If your computer speaks English, it was probably made in Japan.
41. Some programming languages manage to absorb change, but withstand progress.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
19. A language that doesn't affect the way you think about programming, is not worth knowing.
31. Simplicity does not precede complexity, but follows it.
14. In the long run every program becomes rococo - then rubble.
57. It is easier to change the specification to fit the program than vice versa.
102. One can't proceed from the informal to the formal by formal means.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
46. Like punning, programming is a play on words.
78. If your computer speaks English, it was probably made in Japan.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
59. In English every word can be verbed. Would that it were so in our programming languages.
7. It is easier to write an incorrect program than understand a correct one.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
3. Syntactic sugar causes cancer of the semicolon.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
79. A year spent in artificial intelligence is enough to make one believe in God.
14. In the long run every program becomes rococo - then rubble.
27. Once you understand how to write a program get someone else to write it.
40. There are two ways to write error-free programs; only the third one works.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
110. Editing is a rewording activity.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
1. One man's constant is another man's variable.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
17. If a listener nods his head when you're explaining your program, wake him up.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
3. Syntactic sugar causes cancer of the semicolon.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
78. If your computer speaks English, it was probably made in Japan.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
98. In computing, the mean time to failure keeps getting shorter.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
23. To understand a program you must become both the machine and the program.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
105. You can't communicate complexity, only an awareness of it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
95. Don't have good ideas if you aren't willing to be responsible for them.
100. We will never run out of things to program as long as there is a single program around.
12. Recursion is the root of computation since it trades description for time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
59. In English every word can be verbed. Would that it were so in our programming languages.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
108. Whenever two programmers meet to criticize their programs, both are silent.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
18. A program without a loop and a structured variable isn't worth writing.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
1. One man's constant is another man's variable.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
79. A year spent in artificial intelligence is enough to make one believe in God.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
31. Simplicity does not precede complexity, but follows it.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
111. Why did the Roman Empire collapse? What is Latin for office automation?
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
23. To understand a program you must become both the machine and the program.
57. It is easier to change the specification to fit the program than vice versa.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
46. Like punning, programming is a play on words.
22. A good system can't have a weak command language.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
76. It is the user who should parameterize procedures, not their creators.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
111. Why did the Roman Empire collapse? What is Latin for office automation?
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
114. Within a computer natural language is unnatural.
43. In software systems, it is often the early bird that makes the worm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
11. If you have a procedure with ten parameters, you probably missed some.
79. A year spent in artificial intelligence is enough to make one believe in God.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
78. If your computer speaks English, it was probably made in Japan.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
43. In software systems, it is often the early bird that makes the worm.
43. In software systems, it is often the early bird that makes the worm.
57. It is easier to change the specification to fit the program than vice versa.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
119. Programming is an unnatural act.
111. Why did the Roman Empire collapse? What is Latin for office automation?
1. One man's constant is another man's variable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
90. Computation has made the tree flower.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
90. Computation has made the tree flower.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
110. Editing is a rewording activity.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
22. A good system can't have a weak command language.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
100. We will never run out of things to program as long as there is a single program around.
114. Within a computer natural language is unnatural.
78. If your computer speaks English, it was probably made in Japan.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
27. Once you understand how to write a program get someone else to write it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
95. Don't have good ideas if you aren't willing to be responsible for them.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
108. Whenever two programmers meet to criticize their programs, both are silent.
18. A program without a loop and a structured variable isn't worth writing.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
3. Syntactic sugar causes cancer of the semicolon.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
66. Making something variable is easy. Controlling duration of constancy is the trick.
105. You can't communicate complexity, only an awareness of it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
104. The proof of a system's value is its existence.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
41. Some programming languages manage to absorb change, but withstand progress.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
11. If you have a procedure with ten parameters, you probably missed some.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
46. Like punning, programming is a play on words.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
46. Like punning, programming is a play on words.
27. Once you understand how to write a program get someone else to write it.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
108. Whenever two programmers meet to criticize their programs, both are silent.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
21. Optimization hinders evolution.
76. It is the user who should parameterize procedures, not their creators.
46. Like punning, programming is a play on words.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
95. Don't have good ideas if you aren't willing to be responsible for them.
18. A program without a loop and a structured variable isn't worth writing.
59. In English every word can be verbed. Would that it were so in our programming languages.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
1. One man's constant is another man's variable.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21. Optimization hinders evolution.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
14. In the long run every program becomes rococo - then rubble.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
27. Once you understand how to write a program get someone else to write it.
61. In programming, as in everything else, to be in error is to be reborn.
100. We will never run out of things to program as long as there is a single program around.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
41. Some programming languages manage to absorb change, but withstand progress.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
105. You can't communicate complexity, only an awareness of it.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
79. A year spent in artificial intelligence is enough to make one believe in God.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
96. Computers don't introduce order anywhere as much as they expose opportunities.
15. Everything should be built top-down, except the first time.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
11. If you have a procedure with ten parameters, you probably missed some.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
62. In computing, invariants are ephemeral.
22. A good system can't have a weak command language.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
43. In software systems, it is often the early bird that makes the worm.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
119. Programming is an unnatural act.
66. Making something variable is easy. Controlling duration of constancy is the trick.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
114. Within a computer natural language is unnatural.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
114. Within a computer natural language is unnatural.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
57. It is easier to change the specification to fit the program than vice versa.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
114. Within a computer natural language is unnatural.
61. In programming, as in everything else, to be in error is to be reborn.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
46. Like punning, programming is a play on words.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
111. Why did the Roman Empire collapse? What is Latin for office automation?
102. One can't proceed from the informal to the formal by formal means.
119. Programming is an unnatural act.
1. One man's constant is another man's variable.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
8. A programming language is low level when its programs require attention to the irrelevant.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
7. It is easier to write an incorrect program than understand a correct one.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
62. In computing, invariants are ephemeral.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
4. Every program is a part of some other program and rarely fits.
21. Optimization hinders evolution.
102. One can't proceed from the informal to the formal by formal means.
72. An adequate bootstrap is a contradiction in terms.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
17. If a listener nods his head when you're explaining your program, wake him up.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
61. In programming, as in everything else, to be in error is to be reborn.
100. We will never run out of things to program as long as there is a single program around.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
102. One can't proceed from the informal to the formal by formal means.
96. Computers don't introduce order anywhere as much as they expose opportunities.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
47. As Will Rogers would have said, "There is no such thing as a free variable."
114. Within a computer natural language is unnatural.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
95. Don't have good ideas if you aren't willing to be responsible for them.
63. When we write programs that "learn", it turns out that we do and they don't.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
40. There are two ways to write error-free programs; only the third one works.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
103. Purely applicative languages are poorly applicable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
.
299,422c
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
90. Computation has made the tree flower.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
18. A program without a loop and a structured variable isn't worth writing.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
115. Most people find the concept of programming obvious, but the doing impossible.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
21. Optimization hinders evolution.
111. Why did the Roman Empire collapse? What is Latin for office automation?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
41. Some programming languages manage to absorb change, but withstand progress.
61. In programming, as in everything else, to be in error is to be reborn.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
57. It is easier to change the specification to fit the program than vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
66. Making something variable is easy. Controlling duration of constancy is the trick.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
66. Making something variable is easy. Controlling duration of constancy is the trick.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
4. Every program is a part of some other program and rarely fits.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
98. In computing, the mean time to failure keeps getting shorter.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
112. Computer Science is embarrassed by the computer.
7. It is easier to write an incorrect program than understand a correct one.
23. To understand a program you must become both the machine and the program.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
59. In English every word can be verbed. Would that it were so in our programming languages.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
95. Don't have good ideas if you aren't willing to be responsible for them.
15. Everything should be built top-down, except the first time.
41. Some programming languages manage to absorb change, but withstand progress.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
47. As Will Rogers would have said, "There is no such thing as a free variable."
103. Purely applicative languages are poorly applicable.
40. There are two ways to write error-free programs; only the third one works.
59. In English every word can be verbed. Would that it were so in our programming languages.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
11. If you have a procedure with ten parameters, you probably missed some.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
59. In English every word can be verbed. Would that it were so in our programming languages.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
76. It is the user who should parameterize procedures, not their creators.
90. Computation has made the tree flower.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
7. It is easier to write an incorrect program than understand a correct one.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
96. Computers don't introduce order anywhere as much as they expose opportunities.
78. If your computer speaks English, it was probably made in Japan.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
40. There are two ways to write error-free programs; only the third one works.
55. A LISP programmer knows the value of everything, but the cost of nothing.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
66. Making something variable is easy. Controlling duration of constancy is the trick.
66. Making something variable is easy. Controlling duration of constancy is the trick.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
63. When we write programs that "learn", it turns out that we do and they don't.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
40. There are two ways to write error-free programs; only the third one works.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
55. A LISP programmer knows the value of everything, but the cost of nothing.
63. When we write programs that "learn", it turns out that we do and they don't.
17. If a listener nods his head when you're explaining your program, wake him up.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
40. There are two ways to write error-free programs; only the third one works.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
27. Once you understand how to write a program get someone else to write it.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
3. Syntactic sugar causes cancer of the semicolon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
76. It is the user who should parameterize procedures, not their creators.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
59. In English every word can be verbed. Would that it were so in our programming languages.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
3. Syntactic sugar causes cancer of the semicolon.
8. A programming language is low level when its programs require attention to the irrelevant.
.
470,926p
517,625d
510,564c
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
62. In computing, invariants are ephemeral.
61. In programming, as in everything else, to be in error is to be reborn.
23. To understand a program you must become both the machine and the program.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
7. It is easier to write an incorrect program than understand a correct one.
17. If a listener nods his head when you're explaining your program, wake him up.
62. In computing, invariants are ephemeral.
23. To understand a program you must become both the machine and the program.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
43. In software systems, it is often the early bird that makes the worm.
4. Every program is a part of some other program and rarely fits.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
66. Making something variable is easy. Controlling duration of constancy is the trick.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
14. In the long run every program becomes rococo - then rubble.
11. If you have a procedure with ten parameters, you probably missed some.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
31. Simplicity does not precede complexity, but follows it.
22. A good system can't have a weak command language.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
57. It is easier to change the specification to fit the program than vice versa.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
41. Some programming languages manage to absorb change, but withstand progress.
95. Don't have good ideas if you aren't willing to be responsible for them.
12. Recursion is the root of computation since it trades description for time.
110. Editing is a rewording activity.
60. In seeking the unattainable, simplicity only gets in the way.
114. Within a computer natural language is unnatural.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
14. In the long run every program becomes rococo - then rubble.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
.
599,674d
886,956d
484,641p
0,437p
863,934p
704,761p
557,879c
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
57. It is easier to change the specification to fit the program than vice versa.
27. Once you understand how to write a program get someone else to write it.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
38. Structured Programming supports the law of the excluded middle.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
78. If your computer speaks English, it was probably made in Japan.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
62. In computing, invariants are ephemeral.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
61. In programming, as in everything else, to be in error is to be reborn.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
31. Simplicity does not precede complexity, but follows it.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
38. Structured Programming supports the law of the excluded middle.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
114. Within a computer natural language is unnatural.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
38. Structured Programming supports the law of the excluded middle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
61. In programming, as in everything else, to be in error is to be reborn.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
21. Optimization hinders evolution.
55. A LISP programmer knows the value of everything, but the cost of nothing.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
18. A program without a loop and a structured variable isn't worth writing.
15. Everything should be built top-down, except the first time.
110. Editing is a rewording activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
17. If a listener nods his head when you're explaining your program, wake him up.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
23. To understand a program you must become both the machine and the program.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
114. Within a computer natural language is unnatural.
104. The proof of a system's value is its existence.
112. Computer Science is embarrassed by the computer.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
79. A year spent in artificial intelligence is enough to make one believe in God.
100. We will never run out of things to program as long as there is a single program around.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
61. In programming, as in everything else, to be in error is to be reborn.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
55. A LISP programmer knows the value of everything, but the cost of nothing.
31. Simplicity does not precede complexity, but follows it.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
108. Whenever two programmers meet to criticize their programs, both are silent.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
18. A program without a loop and a structured variable isn't worth writing.
79. A year spent in artificial intelligence is enough to make one believe in God.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
22. A good system can't have a weak command language.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
98. In computing, the mean time to failure keeps getting shorter.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
111. Why did the Roman Empire collapse? What is Latin for office automation?
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
31. Simplicity does not precede complexity, but follows it.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
115. Most people find the concept of programming obvious, but the doing impossible.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
22. A good system can't have a weak command language.
31. Simplicity does not precede complexity, but follows it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
41. Some programming languages manage to absorb change, but withstand progress.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
112. Computer Science is embarrassed by the computer.
63. When we write programs that "learn", it turns out that we do and they don't.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
114. Within a computer natural language is unnatural.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
108. Whenever two programmers meet to criticize their programs, both are silent.
119. Programming is an unnatural act.
12. Recursion is the root of computation since it trades description for time.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
38. Structured Programming supports the law of the excluded middle.
102. One can't proceed from the informal to the formal by formal means.
31. Simplicity does not precede complexity, but follows it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
115. Most people find the concept of programming obvious, but the doing impossible.
63. When we write programs that "learn", it turns out that we do and they don't.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
63. When we write programs that "learn", it turns out that we do and they don't.
4. Every program is a part of some other program and rarely fits.
21. Optimization hinders evolution.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
98. In computing, the mean time to failure keeps getting shorter.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
15. Everything should be built top-down, except the first time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
3. Syntactic sugar causes cancer of the semicolon.
47. As Will Rogers would have said, "There is no such thing as a free variable."
3. Syntactic sugar causes cancer of the semicolon.
96. Computers don't introduce order anywhere as much as they expose opportunities.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
55. A LISP programmer knows the value of everything, but the cost of nothing.
12. Recursion is the root of computation since it trades description for time.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
17. If a listener nods his head when you're explaining your program, wake him up.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
22. A good system can't have a weak command language.
95. Don't have good ideas if you aren't willing to be responsible for them.
4. Every program is a part of some other program and rarely fits.
111. Why did the Roman Empire collapse? What is Latin for office automation?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
112. Computer Science is embarrassed by the computer.
8. A programming language is low level when its programs require attention to the irrelevant.
15. Everything should be built top-down, except the first time.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
79. A year spent in artificial intelligence is enough to make one believe in God.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
4. Every program is a part of some other program and rarely fits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
43. In software systems, it is often the early bird that makes the worm.
103. Purely applicative languages are poorly applicable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
14. In the long run every program becomes rococo - then rubble.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
100. We will never run out of things to program as long as there is a single program around.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
100. We will never run out of things to program as long as there is a single program around.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
100. We will never run out of things to program as long as there is a single program around.
112. Computer Science is embarrassed by the computer.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
27. Once you understand how to write a program get someone else to write it.
102. One can't proceed from the informal to the formal by formal means.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
103. Purely applicative languages are poorly applicable.
31. Simplicity does not precede complexity, but follows it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
90. Computation has made the tree flower.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
103. Purely applicative languages are poorly applicable.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
61. In programming, as in everything else, to be in error is to be reborn.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
27. Once you understand how to write a program get someone else to write it.
108. Whenever two programmers meet to criticize their programs, both are silent.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
7. It is easier to write an incorrect program than understand a correct one.
114. Within a computer natural language is unnatural.
40. There are two ways to write error-free programs; only the third one works.
63. When we write programs that "learn", it turns out that we do and they don't.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
119. Programming is an unnatural act.
47. As Will Rogers would have said, "There is no such thing as a free variable."
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
79. A year spent in artificial intelligence is enough to make one believe in God.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
90. Computation has made the tree flower.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
27. Once you understand how to write a program get someone else to write it.
40. There are two ways to write error-free programs; only the third one works.
60. In seeking the unattainable, simplicity only gets in the way.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
72. An adequate bootstrap is a contradiction in terms.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
57. It is easier to change the specification to fit the program than vice versa.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
8. A programming language is low level when its programs require attention to the irrelevant.
104. The proof of a system's value is its existence.
22. A good system can't have a weak command language.
4. Every program is a part of some other program and rarely fits.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
110. Editing is a rewording activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
105. You can't communicate complexity, only an awareness of it.
55. A LISP programmer knows the value of everything, but the cost of nothing.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
61. In programming, as in everything else, to be in error is to be reborn.
110. Editing is a rewording activity.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
17. If a listener nods his head when you're explaining your program, wake him up.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
90. Computation has made the tree flower.
31. Simplicity does not precede complexity, but follows it.
112. Computer Science is embarrassed by the computer.
66. Making something variable is easy. Controlling duration of constancy is the trick.
110. Editing is a rewording activity.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
55. A LISP programmer knows the value of everything, but the cost of nothing.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
7. It is easier to write an incorrect program than understand a correct one.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
98. In computing, the mean time to failure keeps getting shorter.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
46. Like punning, programming is a play on words.
61. In programming, as in everything else, to be in error is to be reborn.
103. Purely applicative languages are poorly applicable.
38. Structured Programming supports the law of the excluded middle.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
.
829,895c
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
11. If you have a procedure with ten parameters, you probably missed some.
15. Everything should be built top-down, except the first time.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
96. Computers don't introduce order anywhere as much as they expose opportunities.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
95. Don't have good ideas if you aren't willing to be responsible for them.
4. Every program is a part of some other program and rarely fits.
114. Within a computer natural language is unnatural.
11. If you have a procedure with ten parameters, you probably missed some.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
57. It is easier to change the specification to fit the program than vice versa.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
108. Whenever two programmers meet to criticize their programs, both are silent.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
47. As Will Rogers would have said, "There is no such thing as a free variable."
72. An adequate bootstrap is a contradiction in terms.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
112. Computer Science is embarrassed by the computer.
102. One can't proceed from the informal to the formal by formal means.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
79. A year spent in artificial intelligence is enough to make one believe in God.
55. A LISP programmer knows the value of everything, but the cost of nothing.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
96. Computers don't introduce order anywhere as much as they expose opportunities.
104. The proof of a system's value is its existence.
111. Why did the Roman Empire collapse? What is Latin for office automation?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
46. Like punning, programming is a play on words.
3. Syntactic sugar causes cancer of the semicolon.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
112. Computer Science is embarrassed by the computer.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
98. In computing, the mean time to failure keeps getting shorter.
18. A program without a loop and a structured variable isn't worth writing.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
72. An adequate bootstrap is a contradiction in terms.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
76. It is the user who should parameterize procedures, not their creators.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
103. Purely applicative languages are poorly applicable.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
23. To understand a program you must become both the machine and the program.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
57. It is easier to change the specification to fit the program than vice versa.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
38. Structured Programming supports the law of the excluded middle.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
90. Computation has made the tree flower.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
.
81,709c
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
31. Simplicity does not precede complexity, but follows it.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
72. An adequate bootstrap is a contradiction in terms.
43. In software systems, it is often the early bird that makes the worm.
59. In English every word can be verbed. Would that it were so in our programming languages.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
104. The proof of a system's value is its existence.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
95. Don't have good ideas if you aren't willing to be responsible for them.
4. Every program is a part of some other program and rarely fits.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
115. Most people find the concept of programming obvious, but the doing impossible.
102. One can't proceed from the informal to the formal by formal means.
23. To understand a program you must become both the machine and the program.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
31. Simplicity does not precede complexity, but follows it.
103. Purely applicative languages are poorly applicable.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
41. Some programming languages manage to absorb change, but withstand progress.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
60. In seeking the unattainable, simplicity only gets in the way.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
14. In the long run every program becomes rococo - then rubble.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
3. Syntactic sugar causes cancer of the semicolon.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
63. When we write programs that "learn", it turns out that we do and they don't.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
12. Recursion is the root of computation since it trades description for time.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
61. In programming, as in everything else, to be in error is to be reborn.
17. If a listener nods his head when you're explaining your program, wake him up.
103. Purely applicative languages are poorly applicable.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
38. Structured Programming supports the law of the excluded middle.
108. Whenever two programmers meet to criticize their programs, both are silent.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
103. Purely applicative languages are poorly applicable.
66. Making something variable is easy. Controlling duration of constancy is the trick.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
110. Editing is a rewording activity.
41. Some programming languages manage to absorb change, but withstand progress.
41. Some programming languages manage to absorb change, but withstand progress.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
108. Whenever two programmers meet to criticize their programs, both are silent.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
76. It is the user who should parameterize procedures, not their creators.
115. Most people find the concept of programming obvious, but the doing impossible.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
96. Computers don't introduce order anywhere as much as they expose opportunities.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
105. You can't communicate complexity, only an awareness of it.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
108. Whenever two programmers meet to criticize their programs, both are silent.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
112. Computer Science is embarrassed by the computer.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
38. Structured Programming supports the law of the excluded middle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
38. Structured Programming supports the law of the excluded middle.
21. Optimization hinders evolution.
14. In the long run every program becomes rococo - then rubble.
79. A year spent in artificial intelligence is enough to make one believe in God.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
1. One man's constant is another man's variable.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
40. There are two ways to write error-free programs; only the third one works.
17. If a listener nods his head when you're explaining your program, wake him up.
111. Why did the Roman Empire collapse? What is Latin for office automation?
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
59. In English every word can be verbed. Would that it were so in our programming languages.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
60. In seeking the unattainable, simplicity only gets in the way.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
103. Purely applicative languages are poorly applicable.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
38. Structured Programming supports the law of the excluded middle.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
47. As Will Rogers would have said, "There is no such thing as a free variable."
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
115. Most people find the concept of programming obvious, but the doing impossible.
14. In the long run every program becomes rococo - then rubble.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
1. One man's constant is another man's variable.
1. One man's constant is another man's variable.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
8. A programming language is low level when its programs require attention to the irrelevant.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
14. In the long run every program becomes rococo - then rubble.
21. Optimization hinders evolution.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
46. Like punning, programming is a play on words.
23. To understand a program you must become both the machine and the program.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
102. One can't proceed from the informal to the formal by formal means.
100. We will never run out of things to program as long as there is a single program around.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
110. Editing is a rewording activity.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
110. Editing is a rewording activity.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
112. Computer Science is embarrassed by the computer.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
1. One man's constant is another man's variable.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
96. Computers don't introduce order anywhere as much as they expose opportunities.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
60. In seeking the unattainable, simplicity only gets in the way.
47. As Will Rogers would have said, "There is no such thing as a free variable."
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
21. Optimization hinders evolution.
47. As Will Rogers would have said, "There is no such thing as a free variable."
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
55. A LISP programmer knows the value of everything, but the cost of nothing.
96. Computers don't introduce order anywhere as much as they expose opportunities.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
21. Optimization hinders evolution.
105. You can't communicate complexity, only an awareness of it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
31. Simplicity does not precede complexity, but follows it.
14. In the long run every program becomes rococo - then rubble.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
3. Syntactic sugar causes cancer of the semicolon.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
23. To understand a program you must become both the machine and the program.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
57. It is easier to change the specification to fit the program than vice versa.
66. Making something variable is easy. Controlling duration of constancy is the trick.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
78. If your computer speaks English, it was probably made in Japan.
60. In seeking the unattainable, simplicity only gets in the way.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
3. Syntactic sugar causes cancer of the semicolon.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
41. Some programming languages manage to absorb change, but withstand progress.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
21. Optimization hinders evolution.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
66. Making something variable is easy. Controlling duration of constancy is the trick.
66. Making something variable is easy. Controlling duration of constancy is the trick.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
110. Editing is a rewording activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
59. In English every word can be verbed. Would that it were so in our programming languages.
43. In software systems, it is often the early bird that makes the worm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
100. We will never run out of things to program as long as there is a single program around.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
7. It is easier to write an incorrect program than understand a correct one.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
110. Editing is a rewording activity.
23. To understand a program you must become both the machine and the program.
62. In computing, invariants are ephemeral.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
110. Editing is a rewording activity.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
43. In software systems, it is often the early bird that makes the worm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
14. In the long run every program becomes rococo - then rubble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
90. Computation has made the tree flower.
43. In software systems, it is often the early bird that makes the worm.
14. In the long run every program becomes rococo - then rubble.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
31. Simplicity does not precede complexity, but follows it.
110. Editing is a rewording activity.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
31. Simplicity does not precede complexity, but follows it.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
41. Some programming languages manage to absorb change, but withstand progress.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
60. In seeking the unattainable, simplicity only gets in the way.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
4. Every program is a part of some other program and rarely fits.
79. A year spent in artificial intelligence is enough to make one believe in God.
55. A LISP programmer knows the value of everything, but the cost of nothing.
43. In software systems, it is often the early bird that makes the worm.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
110. Editing is a rewording activity.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
112. Computer Science is embarrassed by the computer.
11. If you have a procedure with ten parameters, you probably missed some.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
47. As Will Rogers would have said, "There is no such thing as a free variable."
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
38. Structured Programming supports the law of the excluded middle.
4. Every program is a part of some other program and rarely fits.
14. In the long run every program becomes rococo - then rubble.
17. If a listener nods his head when you're explaining your program, wake him up.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
72. An adequate bootstrap is a contradiction in terms.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
41. Some programming languages manage to absorb change, but withstand progress.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
23. To understand a program you must become both the machine and the program.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
4. Every program is a part of some other program and rarely fits.
11. If you have a procedure with ten parameters, you probably missed some.
62. In computing, invariants are ephemeral.
43. In software systems, it is often the early bird that makes the worm.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
18. A program without a loop and a structured variable isn't worth writing.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
60. In seeking the unattainable, simplicity only gets in the way.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
63. When we write programs that "learn", it turns out that we do and they don't.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
7. It is easier to write an incorrect program than understand a correct one.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
17. If a listener nods his head when you're explaining your program, wake him up.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
112. Computer Science is embarrassed by the computer.
18. A program without a loop and a structured variable isn't worth writing.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
90. Computation has made the tree flower.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
38. Structured Programming supports the law of the excluded middle.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
8. A programming language is low level when its programs require attention to the irrelevant.
119. Programming is an unnatural act.
18. A program without a loop and a structured variable isn't worth writing.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
8. A programming language is low level when its programs require attention to the irrelevant.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
105. You can't communicate complexity, only an awareness of it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
3. Syntactic sugar causes cancer of the semicolon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
47. As Will Rogers would have said, "There is no such thing as a free variable."
19. A language that doesn't affect the way you think about programming, is not worth knowing.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
90. Computation has made the tree flower.
115. Most people find the concept of programming obvious, but the doing impossible.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
105. You can't communicate complexity, only an awareness of it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
23. To understand a program you must become both the machine and the program.
14. In the long run every program becomes rococo - then rubble.
46. Like punning, programming is a play on words.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
60. In seeking the unattainable, simplicity only gets in the way.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
8. A programming language is low level when its programs require attention to the irrelevant.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
41. Some programming languages manage to absorb change, but withstand progress.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
12. Recursion is the root of computation since it trades description for time.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
114. Within a computer natural language is unnatural.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
55. A LISP programmer knows the value of everything, but the cost of nothing.
11. If you have a procedure with ten parameters, you probably missed some.
108. Whenever two programmers meet to criticize their programs, both are silent.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
63. When we write programs that "learn", it turns out that we do and they don't.
114. Within a computer natural language is unnatural.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
27. Once you understand how to write a program get someone else to write it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
3. Syntactic sugar causes cancer of the semicolon.
110. Editing is a rewording activity.
31. Simplicity does not precede complexity, but follows it.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
98. In computing, the mean time to failure keeps getting shorter.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
38. Structured Programming supports the law of the excluded middle.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
14. In the long run every program becomes rococo - then rubble.
22. A good system can't have a weak command language.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
46. Like punning, programming is a play on words.
62. In computing, invariants are ephemeral.
95. Don't have good ideas if you aren't willing to be responsible for them.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
40. There are two ways to write error-free programs; only the third one works.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
7. It is easier to write an incorrect program than understand a correct one.
11. If you have a procedure with ten parameters, you probably missed some.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
17. If a listener nods his head when you're explaining your program, wake him up.
27. Once you understand how to write a program get someone else to write it.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
114. Within a computer natural language is unnatural.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
114. Within a computer natural language is unnatural.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
18. A program without a loop and a structured variable isn't worth writing.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
1. One man's constant is another man's variable.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
43. In software systems, it is often the early bird that makes the worm.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
1. One man's constant is another man's variable.
1. One man's constant is another man's variable.
62. In computing, invariants are ephemeral.
102. One can't proceed from the informal to the formal by formal means.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
27. Once you understand how to write a program get someone else to write it.
96. Computers don't introduce order anywhere as much as they expose opportunities.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
108. Whenever two programmers meet to criticize their programs, both are silent.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
18. A program without a loop and a structured variable isn't worth writing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
114. Within a computer natural language is unnatural.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
11. If you have a procedure with ten parameters, you probably missed some.
41. Some programming languages manage to absorb change, but withstand progress.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
55. A LISP programmer knows the value of everything, but the cost of nothing.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
98. In computing, the mean time to failure keeps getting shorter.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
100. We will never run out of things to program as long as there is a single program around.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
108. Whenever two programmers meet to criticize their programs, both are silent.
27. Once you understand how to write a program get someone else to write it.
60. In seeking the unattainable, simplicity only gets in the way.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
112. Computer Science is embarrassed by the computer.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
22. A good system can't have a weak command language.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
15. Everything should be built top-down, except the first time.
79. A year spent in artificial intelligence is enough to make one believe in God.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
22. A good system can't have a weak command language.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
63. When we write programs that "learn", it turns out that we do and they don't.
110. Editing is a rewording activity.
102. One can't proceed from the informal to the formal by formal means.
43. In software systems, it is often the early bird that makes the worm.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
12. Recursion is the root of computation since it trades description for time.
8. A programming language is low level when its programs require attention to the irrelevant.
12. Recursion is the root of computation since it trades description for time.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
108. Whenever two programmers meet to criticize their programs, both are silent.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
12. Recursion is the root of computation since it trades description for time.
22. A good system can't have a weak command language.
76. It is the user who should parameterize procedures, not their creators.
95. Don't have good ideas if you aren't willing to be responsible for them.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
96. Computers don't introduce order anywhere as much as they expose opportunities.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
79. A year spent in artificial intelligence is enough to make one believe in God.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
38. Structured Programming supports the law of the excluded middle.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
100. We will never run out of things to program as long as there is a single program around.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
8. A programming language is low level when its programs require attention to the irrelevant.
61. In programming, as in everything else, to be in error is to be reborn.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
27. Once you understand how to write a program get someone else to write it.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
40. There are two ways to write error-free programs; only the third one works.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
8. A programming language is low level when its programs require attention to the irrelevant.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
108. Whenever two programmers meet to criticize their programs, both are silent.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
66. Making something variable is easy. Controlling duration of constancy is the trick.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
.
799,833p
455,1011c
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
60. In seeking the unattainable, simplicity only gets in the way.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
114. Within a computer natural language is unnatural.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
76. It is the user who should parameterize procedures, not their creators.
59. In English every word can be verbed. Would that it were so in our programming languages.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
72. An adequate bootstrap is a contradiction in terms.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
57. It is easier to change the specification to fit the program than vice versa.
1. One man's constant is another man's variable.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
62. In computing, invariants are ephemeral.
115. Most people find the concept of programming obvious, but the doing impossible.
78. If your computer speaks English, it was probably made in Japan.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
55. A LISP programmer knows the value of everything, but the cost of nothing.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
78. If your computer speaks English, it was probably made in Japan.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
100. We will never run out of things to program as long as there is a single program around.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
8. A programming language is low level when its programs require attention to the irrelevant.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
15. Everything should be built top-down, except the first time.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
63. When we write programs that "learn", it turns out that we do and they don't.
98. In computing, the mean time to failure keeps getting shorter.
40. There are two ways to write error-free programs; only the third one works.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
115. Most people find the concept of programming obvious, but the doing impossible.
15. Everything should be built top-down, except the first time.
22. A good system can't have a weak command language.
66. Making something variable is easy. Controlling duration of constancy is the trick.
40. There are two ways to write error-free programs; only the third one works.
47. As Will Rogers would have said, "There is no such thing as a free variable."
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
78. If your computer speaks English, it was probably made in Japan.
102. One can't proceed from the informal to the formal by formal means.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
72. An adequate bootstrap is a contradiction in terms.
47. As Will Rogers would have said, "There is no such thing as a free variable."
62. In computing, invariants are ephemeral.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
18. A program without a loop and a structured variable isn't worth writing.
76. It is the user who should parameterize procedures, not their creators.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
102. One can't proceed from the informal to the formal by formal means.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
72. An adequate bootstrap is a contradiction in terms.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
57. It is easier to change the specification to fit the program than vice versa.
12. Recursion is the root of computation since it trades description for time.
66. Making something variable is easy. Controlling duration of constancy is the trick.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
103. Purely applicative languages are poorly applicable.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
49. Giving up on assembly language was the apple in our Garden of Eden: Languages whose use squanders machine cycles are sinful. The LISP machine now permits LISP programmers to abandon bra and fig-leaf.
14. In the long run every program becomes rococo - then rubble.
61. In programming, as in everything else, to be in error is to be reborn.
76. It is the user who should parameterize procedures, not their creators.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
57. It is easier to change the specification to fit the program than vice versa.
15. Everything should be built top-down, except the first time.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
115. Most people find the concept of programming obvious, but the doing impossible.
111. Why did the Roman Empire collapse? What is Latin for office automation?
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
105. You can't communicate complexity, only an awareness of it.
17. If a listener nods his head when you're explaining your program, wake him up.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
114. Within a computer natural language is unnatural.
108. Whenever two programmers meet to criticize their programs, both are silent.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
14. In the long run every program becomes rococo - then rubble.
8. A programming language is low level when its programs require attention to the irrelevant.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
59. In English every word can be verbed. Would that it were so in our programming languages.
55. A LISP programmer knows the value of everything, but the cost of nothing.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
3. Syntactic sugar causes cancer of the semicolon.
66. Making something variable is easy. Controlling duration of constancy is the trick.
95. Don't have good ideas if you aren't willing to be responsible for them.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
119. Programming is an unnatural act.
55. A LISP programmer knows the value of everything, but the cost of nothing.
47. As Will Rogers would have said, "There is no such thing as a free variable."
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
62. In computing, invariants are ephemeral.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
66. Making something variable is easy. Controlling duration of constancy is the trick.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
11. If you have a procedure with ten parameters, you probably missed some.
98. In computing, the mean time to failure keeps getting shorter.
55. A LISP programmer knows the value of everything, but the cost of nothing.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
43. In software systems, it is often the early bird that makes the worm.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
78. If your computer speaks English, it was probably made in Japan.
27. Once you understand how to write a program get someone else to write it.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
62. In computing, invariants are ephemeral.
114. Within a computer natural language is unnatural.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
96. Computers don't introduce order anywhere as much as they expose opportunities.
59. In English every word can be verbed. Would that it were so in our programming languages.
76. It is the user who should parameterize procedures, not their creators.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
98. In computing, the mean time to failure keeps getting shorter.
31. Simplicity does not precede complexity, but follows it.
66. Making something variable is easy. Controlling duration of constancy is the trick.
100. We will never run out of things to program as long as there is a single program around.
95. Don't have good ideas if you aren't willing to be responsible for them.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
104. The proof of a system's value is its existence.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
21. Optimization hinders evolution.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
104. The proof of a system's value is its existence.
60. In seeking the unattainable, simplicity only gets in the way.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
4. Every program is a part of some other program and rarely fits.
62. In computing, invariants are ephemeral.
15. Everything should be built top-down, except the first time.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
1. One man's constant is another man's variable.
4. Every program is a part of some other program and rarely fits.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
14. In the long run every program becomes rococo - then rubble.
15. Everything should be built top-down, except the first time.
76. It is the user who should parameterize procedures, not their creators.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
47. As Will Rogers would have said, "There is no such thing as a free variable."
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
23. To understand a program you must become both the machine and the program.
55. A LISP programmer knows the value of everything, but the cost of nothing.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
111. Why did the Roman Empire collapse? What is Latin for office automation?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
23. To understand a program you must become both the machine and the program.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
98. In computing, the mean time to failure keeps getting shorter.
14. In the long run every program becomes rococo - then rubble.
72. An adequate bootstrap is a contradiction in terms.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
12. Recursion is the root of computation since it trades description for time.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
103. Purely applicative languages are poorly applicable.
63. When we write programs that "learn", it turns out that we do and they don't.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
43. In software systems, it is often the early bird that makes the worm.
98. In computing, the mean time to failure keeps getting shorter.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
43. In software systems, it is often the early bird that makes the worm.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
72. An adequate bootstrap is a contradiction in terms.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
46. Like punning, programming is a play on words.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
7. It is easier to write an incorrect program than understand a correct one.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
55. A LISP programmer knows the value of everything, but the cost of nothing.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
11. If you have a procedure with ten parameters, you probably missed some.
3. Syntactic sugar causes cancer of the semicolon.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
103. Purely applicative languages are poorly applicable.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
78. If your computer speaks English, it was probably made in Japan.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
104. The proof of a system's value is its existence.
1. One man's constant is another man's variable.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
4. Every program is a part of some other program and rarely fits.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
98. In computing, the mean time to failure keeps getting shorter.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
43. In software systems, it is often the early bird that makes the worm.
72. An adequate bootstrap is a contradiction in terms.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
95. Don't have good ideas if you aren't willing to be responsible for them.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
111. Why did the Roman Empire collapse? What is Latin for office automation?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
61. In programming, as in everything else, to be in error is to be reborn.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
102. One can't proceed from the informal to the formal by formal means.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
23. To understand a program you must become both the machine and the program.
47. As Will Rogers would have said, "There is no such thing as a free variable."
60. In seeking the unattainable, simplicity only gets in the way.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
1. One man's constant is another man's variable.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
110. Editing is a rewording activity.
76. It is the user who should parameterize procedures, not their creators.
105. You can't communicate complexity, only an awareness of it.
43. In software systems, it is often the early bird that makes the worm.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
102. One can't proceed from the informal to the formal by formal means.
98. In computing, the mean time to failure keeps getting shorter.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
115. Most people find the concept of programming obvious, but the doing impossible.
23. To understand a program you must become both the machine and the program.
76. It is the user who should parameterize procedures, not their creators.
27. Once you understand how to write a program get someone else to write it.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
14. In the long run every program becomes rococo - then rubble.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
22. A good system can't have a weak command language.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
8. A programming language is low level when its programs require attention to the irrelevant.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
5. If a program manipulates a large amount of data, it does so in a small number of ways.
63. When we write programs that "learn", it turns out that we do and they don't.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
17. If a listener nods his head when you're explaining your program, wake him up.
108. Whenever two programmers meet to criticize their programs, both are silent.
12. Recursion is the root of computation since it trades description for time.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
61. In programming, as in everything else, to be in error is to be reborn.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
76. It is the user who should parameterize procedures, not their creators.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
11. If you have a procedure with ten parameters, you probably missed some.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
90. Computation has made the tree flower.
66. Making something variable is easy. Controlling duration of constancy is the trick.
103. Purely applicative languages are poorly applicable.
79. A year spent in artificial intelligence is enough to make one believe in God.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
115. Most people find the concept of programming obvious, but the doing impossible.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
22. A good system can't have a weak command language.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
4. Every program is a part of some other program and rarely fits.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
43. In software systems, it is often the early bird that makes the worm.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
96. Computers don't introduce order anywhere as much as they expose opportunities.
18. A program without a loop and a structured variable isn't worth writing.
105. You can't communicate complexity, only an awareness of it.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
105. You can't communicate complexity, only an awareness of it.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
31. Simplicity does not precede complexity, but follows it.
11. If you have a procedure with ten parameters, you probably missed some.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
100. We will never run out of things to program as long as there is a single program around.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
12. Recursion is the root of computation since it trades description for time.
21. Optimization hinders evolution.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
61. In programming, as in everything else, to be in error is to be reborn.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
119. Programming is an unnatural act.
79. A year spent in artificial intelligence is enough to make one believe in God.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
18. A program without a loop and a structured variable isn't worth writing.
102. One can't proceed from the informal to the formal by formal means.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
102. One can't proceed from the informal to the formal by formal means.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
90. Computation has made the tree flower.
90. Computation has made the tree flower.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
59. In English every word can be verbed. Would that it were so in our programming languages.
119. Programming is an unnatural act.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
7. It is easier to write an incorrect program than understand a correct one.
40. There are two ways to write error-free programs; only the third one works.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
62. In computing, invariants are ephemeral.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
108. Whenever two programmers meet to criticize their programs, both are silent.
104. The proof of a system's value is its existence.
55. A LISP programmer knows the value of everything, but the cost of nothing.
102. One can't proceed from the informal to the formal by formal means.
27. Once you understand how to write a program get someone else to write it.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
47. As Will Rogers would have said, "There is no such thing as a free variable."
98. In computing, the mean time to failure keeps getting shorter.
119. Programming is an unnatural act.
98. In computing, the mean time to failure keeps getting shorter.
4. Every program is a part of some other program and rarely fits.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
78. If your computer speaks English, it was probably made in Japan.
14. In the long run every program becomes rococo - then rubble.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
119. Programming is an unnatural act.
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
112. Computer Science is embarrassed by the computer.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
100. We will never run out of things to program as long as there is a single program around.
100. We will never run out of things to program as long as there is a single program around.
111. Why did the Roman Empire collapse? What is Latin for office automation?
14. In the long run every program becomes rococo - then rubble.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
27. Once you understand how to write a program get someone else to write it.
1. One man's constant is another man's variable.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
78. If your computer speaks English, it was probably made in Japan.
98. In computing, the mean time to failure keeps getting shorter.
16. Every program has (at least) two purposes: the one for which it was written, and another for which it wasn't.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
79. A year spent in artificial intelligence is enough to make one believe in God.
22. A good system can't have a weak command language.
96. Computers don't introduce order anywhere as much as they expose opportunities.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
12. Recursion is the root of computation since it trades description for time.
78. If your computer speaks English, it was probably made in Japan.
63. When we write programs that "learn", it turns out that we do and they don't.
11. If you have a procedure with ten parameters, you probably missed some.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
108. Whenever two programmers meet to criticize their programs, both are silent.
46. Like punning, programming is a play on words.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
55. A LISP programmer knows the value of everything, but the cost of nothing.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
76. It is the user who should parameterize procedures, not their creators.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
76. It is the user who should parameterize procedures, not their creators.
4. Every program is a part of some other program and rarely fits.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
3. Syntactic sugar causes cancer of the semicolon.
104. The proof of a system's value is its existence.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
105. You can't communicate complexity, only an awareness of it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
76. It is the user who should parameterize procedures, not their creators.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
119. Programming is an unnatural act.
57. It is easier to change the specification to fit the program than vice versa.
43. In software systems, it is often the early bird that makes the worm.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
96. Computers don't introduce order anywhere as much as they expose opportunities.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
57. It is easier to change the specification to fit the program than vice versa.
90. Computation has made the tree flower.
95. Don't have good ideas if you aren't willing to be responsible for them.
85. Though the Chinese should adore APL, it's FORTRAN they put their money on.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
27. Once you understand how to write a program get someone else to write it.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
59. In English every word can be verbed. Would that it were so in our programming languages.
100. We will never run out of things to program as long as there is a single program around.
55. A LISP programmer knows the value of everything, but the cost of nothing.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
110. Editing is a rewording activity.
83. What is the difference between a Turing machine and the modern computer? It's the same as that between Hillary's ascent of Everest and the establishment of a Hilton hotel on its peak.
108. Whenever two programmers meet to criticize their programs, both are silent.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
113. The only constructive theory connecting neuroscience and psychology will arise from the study of software.
27. Once you understand how to write a program get someone else to write it.
25. One can only display complex information in the mind. Like seeing, movement or flow or alteration of view is more important than the static picture, no matter how lovely.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
8. A programming language is low level when its programs require attention to the irrelevant.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
52. Systems have sub-systems and sub-systems have sub- systems and so on ad infinitum - which is why we're always starting over.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
119. Programming is an unnatural act.
41. Some programming languages manage to absorb change, but withstand progress.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
57. It is easier to change the specification to fit the program than vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
98. In computing, the mean time to failure keeps getting shorter.
96. Computers don't introduce order anywhere as much as they expose opportunities.
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
104. The proof of a system's value is its existence.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
102. One can't proceed from the informal to the formal by formal means.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
98. In computing, the mean time to failure keeps getting shorter.
63. When we write programs that "learn", it turns out that we do and they don't.
68. If we believe in data structures, we must believe in independent (hence simultaneous) processing. For why else would we collect items within a structure? Why do we tolerate languages that give us the one without the other?
118. If you can imagine a society in which the computer- robot is the only menial, you can imagine anything.
13. If two people write exactly the same program, each should be put into microcode and then they certainly won't be the same.
.
731,939p
782,944c
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
90. Computation has made the tree flower.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
4. Every program is a part of some other program and rarely fits.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
35. Everyone can be taught to sculpt: Michelangelo would have had to be taught not to. So it is with great programmers.
61. In programming, as in everything else, to be in error is to be reborn.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
47. As Will Rogers would have said, "There is no such thing as a free variable."
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
11. If you have a procedure with ten parameters, you probably missed some.
57. It is easier to change the specification to fit the program than vice versa.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
38. Structured Programming supports the law of the excluded middle.
76. It is the user who should parameterize procedures, not their creators.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
78. If your computer speaks English, it was probably made in Japan.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
105. You can't communicate complexity, only an awareness of it.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
60. In seeking the unattainable, simplicity only gets in the way.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
17. If a listener nods his head when you're explaining your program, wake him up.
105. You can't communicate complexity, only an awareness of it.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
111. Why did the Roman Empire collapse? What is Latin for office automation?
4. Every program is a part of some other program and rarely fits.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
7. It is easier to write an incorrect program than understand a correct one.
62. In computing, invariants are ephemeral.
18. A program without a loop and a structured variable isn't worth writing.
18. A program without a loop and a structured variable isn't worth writing.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
55. A LISP programmer knows the value of everything, but the cost of nothing.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
11. If you have a procedure with ten parameters, you probably missed some.
104. The proof of a system's value is its existence.
40. There are two ways to write error-free programs; only the third one works.
15. Everything should be built top-down, except the first time.
111. Why did the Roman Empire collapse? What is Latin for office automation?
103. Purely applicative languages are poorly applicable.
20. Wherever there is modularity there is the potential for misunderstanding: Hiding information implies a need to check communication.
112. Computer Science is embarrassed by the computer.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
41. Some programming languages manage to absorb change, but withstand progress.
30. In programming, everything we do is a special case of something more general -- and often we know it too quickly.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
97. When a professor insists computer science is X but not Y, have compassion for his graduate students.
9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.
61. In programming, as in everything else, to be in error is to be reborn.
70. Over the centuries the Indians developed sign language for communicating phenomena of interest. Programmers from different tribes (FORTRAN, LISP, ALGOL, SNOBOL, etc.) could use one that doesn't require them to carry a blackboard on their ponies.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
14. In the long run every program becomes rococo - then rubble.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
3. Syntactic sugar causes cancer of the semicolon.
6. Symmetry is a complexity-reducing concept (co-routines include subroutines); seek it everywhere.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
40. There are two ways to write error-free programs; only the third one works.
59. In English every word can be verbed. Would that it were so in our programming languages.
24. Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
62. In computing, invariants are ephemeral.
103. Purely applicative languages are poorly applicable.
14. In the long run every program becomes rococo - then rubble.
84. Motto for a research laboratory: What we work on today, others will first think of tomorrow.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
51. Bringing computers into the home won't change either one, but may revitalize the corner saloon.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
107. The debate rages on: is PL/I Bachtrian or Dromedary?
116. You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program.
14. In the long run every program becomes rococo - then rubble.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
31. Simplicity does not precede complexity, but follows it.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
71. Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
53. So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
11. If you have a procedure with ten parameters, you probably missed some.
99. In man-machine symbiosis, it is man who must adjust: The machines can't.
88. It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
17. If a listener nods his head when you're explaining your program, wake him up.
77. The cybernetic exchange between man, computer and algorithm is like a game of musical chairs: The frantic search for balance always leaves one of the three standing ill at ease.
46. Like punning, programming is a play on words.
72. An adequate bootstrap is a contradiction in terms.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
47. As Will Rogers would have said, "There is no such thing as a free variable."
61. In programming, as in everything else, to be in error is to be reborn.
94. Interfaces keep things tidy, but don't accelerate growth: Functions do.
18. A program without a loop and a structured variable isn't worth writing.
31. Simplicity does not precede complexity, but follows it.
110. Editing is a rewording activity.
100. We will never run out of things to program as long as there is a single program around.
115. Most people find the concept of programming obvious, but the doing impossible.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
110. Editing is a rewording activity.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
106. It's difficult to extract sense from strings, but they're the only communication coin we can count on.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
27. Once you understand how to write a program get someone else to write it.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
22. A good system can't have a weak command language.
112. Computer Science is embarrassed by the computer.
21. Optimization hinders evolution.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
74. Is it possible that software is not like anything else, that it is meant to be discarded: that the whole point is to see it as a soap bubble?
65. Make no mistake about it: Computers process numbers - not symbols. We measure our understanding (and control) by the extent to which we can arithmetize an activity.
38. Structured Programming supports the law of the excluded middle.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
18. A program without a loop and a structured variable isn't worth writing.
57. It is easier to change the specification to fit the program than vice versa.
69. In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will be.
78. If your computer speaks English, it was probably made in Japan.
104. The proof of a system's value is its existence.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
86. We kid ourselves if we think that the ratio of procedure to data in an active data-base system can be made arbitrarily small or even kept small.
55. A LISP programmer knows the value of everything, but the cost of nothing.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
37. The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator. The standarization of real computers would be a disaster - and so it probably won't happen.
78. If your computer speaks English, it was probably made in Japan.
61. In programming, as in everything else, to be in error is to be reborn.
28. Around computers it is difficult to find the correct unit of time to measure progress. Some cathedrals took a century to complete. Can you imagine the grandeur and scope of a program that would take as long?
60. In seeking the unattainable, simplicity only gets in the way.
72. An adequate bootstrap is a contradiction in terms.
89. One does not learn computing by using a hand calculator, but one can forget arithmetic.
31. Simplicity does not precede complexity, but follows it.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
8. A programming language is low level when its programs require attention to the irrelevant.
91. The computer reminds one of Lon Chaney -- it is the machine of a thousand faces.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
79. A year spent in artificial intelligence is enough to make one believe in God.
.
455,527c
87. We have the mini and the micro computer. In what semantic niche would the pico computer fall?
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
104. The proof of a system's value is its existence.
75. Because of its vitality, the computing field is always in desperate need of new cliches: Banality soothes our nerves.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
72. An adequate bootstrap is a contradiction in terms.
44. Sometimes I think the only universal in the computing field is the fetch-execute cycle.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
7. It is easier to write an incorrect program than understand a correct one.
22. A good system can't have a weak command language.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
29. For systems, the analogue of a face-lift is to add to the control graph an edge that creates a cycle, not just an additional node.
50. When we understand knowledge-based systems, it will be as before -- except our fingertips will have been singed.
33. The eleventh commandment was "Thou Shalt Compute" or "Thou Shalt Not Compute" - I forget which.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
15. Everything should be built top-down, except the first time.
36. The use of a program to prove the 4-color theorem will not change mathematics - it merely demonstrates that the theorem, a challenge for a century, is probably not important to mathematics.
19. A language that doesn't affect the way you think about programming, is not worth knowing.
43. In software systems, it is often the early bird that makes the worm.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
39. Re graphics: A picture is worth 10K words - but only those to describe the picture. Hardly any sets of 10K words can be adequately described with pictures.
67. Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
12. Recursion is the root of computation since it trades description for time.
12. Recursion is the root of computation since it trades description for time.
45. The goal of computation is the emulation of our synthetic abilities, not the understanding of our analytic ones.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
56. Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.
5. If a program manipulates a large amount of data, it does so in a small number of ways.
48. The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.
58. Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
19. A language that doesn't affect the way you think about programming, is not worth knowing.
76. It is the user who should parameterize procedures, not their creators.
26. There will always be things we wish to say in our programs that in all known languages can only be said poorly.
23. To understand a program you must become both the machine and the program.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
62. In computing, invariants are ephemeral.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
80. Prolonged contact with the computer turns mathematicians into clerks and vice versa.
60. In seeking the unattainable, simplicity only gets in the way.
34. The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
110. Editing is a rewording activity.
15. Everything should be built top-down, except the first time.
64. Often it is the means that justify the ends: Goals advance technique and technique survives even when goal structures crumble.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
82. We are on the verge: Today our program proved Fermat's next-to-last theorem.
117. It goes against the grain of modern education to teach children to program. What fun is there in making plans, acquiring discipline in organizing thoughts, devoting attention to detail and learning to be self-critical?
54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
42. You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.
11. If you have a procedure with ten parameters, you probably missed some.
73. It is not a language's weakness but its strengths that control the gradient of its change: Alas, a language never escapes its embryonic sac.
55. A LISP programmer knows the value of everything, but the cost of nothing.
12. Recursion is the root of computation since it trades description for time.
10. Get into a rut early: Do the same process the same way. Accumulate idioms. Standardize. The only difference(!) between Shakespeare and you was the size of his idiom list - not the size of his vocabulary.
4. Every program is a part of some other program and rarely fits.
109. Think of it! With VLSI we can pack 100 ENIACS in 1 sq. cm.
101. Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.
119. Programming is an unnatural act.
32. Programmers are not to be measured by their ingenuity and their logic but by the completeness of their case analysis.
2. Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process.
119. Programming is an unnatural act.
120. Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.
93. When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.
7. It is easier to write an incorrect program than understand a correct one.
8. A programming language is low level when its programs require attention to the irrelevant.
92. The computer is the ultimate polluter: its feces are indistinguish- able from the food it produces.
98. In computing, the mean time to failure keeps getting shorter.
81. In computing, turning the obvious into the useful is a living definition of the word "frustration".
66. Making something variable is easy. Controlling duration of constancy is the trick.
.
q
